using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;
using Orleans.Analyzers;
using Xunit;

namespace Analyzers.Tests;

[TestCategory("BVT"), TestCategory("Analyzer")]
public class AtMostOneOrleansConstructorAnalyzerTest : DiagnosticAnalyzerTestBase<AtMostOneOrleansConstructorAnalyzer>
{
    [Fact]
    public async Task TypeWithMultipleAttributedConstructors_ShouldTriggerDiagnostic()
    {
        var diagnostics = await GetDiagnosticsAsync(
            """
            [Orleans.GenerateSerializer]
            public class C
            {
                [Orleans.GenerateSerializer]
                public C()
                {
                }

                [Orleans.GenerateSerializer]
                public C(int value)
                {
                }
            }
            """);

        Assert.NotEmpty(diagnostics);
        Assert.Single(diagnostics);
        Assert.Equal(AtMostOneOrleansConstructorAnalyzer.RuleId, diagnostics[0].Id);
        Assert.Equal(DiagnosticSeverity.Error, diagnostics[0].Severity);
    }

    [Fact]
    public async Task TypeWithSingleAttributedConstructor_ShouldNotTriggerDiagnostic()
    {
        var diagnostics = await GetDiagnosticsAsync(
            """
            [Orleans.GenerateSerializer]
            public class C
            {
                [Orleans.GenerateSerializer]
                public C()
                {
                }

                public C(int value)
                {
                }
            }
            """);

        Assert.Empty(diagnostics);
    }

    [Fact]
    public async Task TypeWithoutGenerateSerializerAttribute_ShouldNotTriggerDiagnostic()
    {
        var diagnostics = await GetDiagnosticsAsync(
            """
            public class C
            {
                [Orleans.GenerateSerializer]
                public C()
                {
                }

                [Orleans.GenerateSerializer]
                public C(int value)
                {
                }
            }
            """);

        Assert.Empty(diagnostics);
    }

    [Fact]
    public async Task GeneratedCodeWithMultipleAttributedConstructors_ShouldNotTriggerDiagnostic()
    {
        var diagnostics = await GetDiagnosticsAsync(
            """
            // <auto-generated/>
            [Orleans.GenerateSerializer]
            public class C
            {
                [Orleans.GenerateSerializer]
                public C()
                {
                }

                [Orleans.GenerateSerializer]
                public C(int value)
                {
                }
            }
            """);

        Assert.Empty(diagnostics);
    }

    private static async Task<Diagnostic[]> GetDiagnosticsAsync(string source)
    {
        const string attributeDefinition = """
            namespace Orleans;

            [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Constructor)]
            public sealed class GenerateSerializerAttribute : System.Attribute
            {
            }
            """;

        var compilation = CreateCompilation(
            "TestProject",
            [CSharpSyntaxTree.ParseText(attributeDefinition), CSharpSyntaxTree.ParseText(source)],
            GetMetadataReferences());

        var analyzer = new AtMostOneOrleansConstructorAnalyzer();
        var diagnostics = await compilation
            .WithOptions(
                compilation.Options.WithSpecificDiagnosticOptions(
                    analyzer.SupportedDiagnostics.ToDictionary(d => d.Id, d => ReportDiagnostic.Default)))
            .WithAnalyzers([analyzer])
            .GetAnalyzerDiagnosticsAsync();

        return diagnostics.ToArray();
    }

    private static CSharpCompilation CreateCompilation(string assemblyName, IEnumerable<SyntaxTree> syntaxTrees, IEnumerable<MetadataReference> references)
        => CSharpCompilation.Create(
            assemblyName,
            syntaxTrees,
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

    private static IReadOnlyCollection<MetadataReference> GetMetadataReferences()
    {
        var assemblies = new[]
        {
            typeof(object).Assembly,
            typeof(Attribute).Assembly,
            typeof(Enumerable).Assembly,
        };

        var metadataReferences = assemblies
            .SelectMany(x => x.GetReferencedAssemblies().Select(Assembly.Load))
            .Concat(assemblies)
            .Distinct()
            .Select(x => MetadataReference.CreateFromFile(x.Location))
            .ToList();

        var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location);
        metadataReferences.Add(MetadataReference.CreateFromFile(Path.Combine(assemblyPath!, "mscorlib.dll")));
        metadataReferences.Add(MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.dll")));
        metadataReferences.Add(MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Core.dll")));
        metadataReferences.Add(MetadataReference.CreateFromFile(Path.Combine(assemblyPath, "System.Runtime.dll")));

        return metadataReferences;
    }
}
