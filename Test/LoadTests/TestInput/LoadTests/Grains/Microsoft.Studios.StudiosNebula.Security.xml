<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Studios.StudiosNebula.Security</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.Jwt.JwtTokenParser">
            <summary>
            <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> implementation for JSON Web Tokens
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.TokenParser">
            <summary>
            Abstract base class for parsing authentication tokens
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParser.ReadToken(System.String)">
            <summary>
            Gets a principal for the specified token
            </summary>
            <param name="token">The token to read</param>
            <returns>A principal for the specified token</returns>
            <exception cref="T:System.ArgumentNullException">
            is thrown when <paramref name="token"/> is <c>null</c>
            </exception>
            <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
            is thrown when a problem occurs while processing a security token
            </exception>
            <exception cref="T:System.InvalidOperationException">
            is thrown when a token cannot be read using the current configuration
            </exception>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.Jwt.JwtTokenParser.#ctor(System.IdentityModel.Tokens.TokenValidationParameters)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.Jwt.JwtTokenParser"/> class
            </summary>
            <param name="parameters">The token validation parameters</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.Jwt.JwtTokenParser.ReadToken(System.String)">
            <summary>
            Gets a principal for the specified token
            </summary>
            <param name="token">The token to read</param>
            <returns>A principal for the specified token</returns>
            <exception cref="T:System.ArgumentNullException">
            is thrown when <paramref name="token"/> is <c>null</c>
            </exception>
            <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
            is thrown when a problem occurs while processing a security token
            </exception>
            <exception cref="T:System.InvalidOperationException">
            is thrown when a token cannot be read using the current configuration
            </exception>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.Jwt.JwtTokenParser.Parameters">
            <summary>
            Gets the token validation parameters
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.EncryptionProvider">
            <summary>
            Provide encryption and decryption logics
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.EncryptionProvider.NonceBytes">
             Size of the IV/Nonce (in bytes).
            
             Recommendation is 12 bytes, via:
             http://blogs.msdn.com/b/shawnfa/archive/2009/03/17/authenticated-symmetric-encryption-in-net.aspx
            
             Which agrees with the official NIST recommendation (see Section 8):
             http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.EncryptionProvider.TagBits">
             Size of the authentication tag (in bits).
            
             This must be one of the legal values specified by
             Security.Cryptography.AuthenticatedSymmetricAlgorithm.LegalTagSize
             (MinSize=96, MaxSize=128, SkipSize=8)
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity">
            <Summary>
            PlayerIdentity
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.SetFlags(System.String)">
            <summary>
            Reading privilege from XSTS claims and set to flags
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.GetDelegationTokenFormat">
            <summary>
            Convert flags to DelegationTokenFormat which will be used by Claims generated by SpartanToken
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.GetDelegationTokenVersion">
            <summary>
            Convert flags to the version of delegation token which will be used by Claims generated by SpartanToken
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.#ctor">
            <Summary>
            Special claims from Halo
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.Reset">
            <Summary>
            Reset instance and re-initialize the members.
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.GetHashCode">
            <summary>
            Calculating hash code using next formula
            for each property
            result = (result * 397) ^ [property's hash code];
            397 is a prime of sufficient size to cause the result variable to overflow 
            and mix the bits of the hash somewhat, providing a better distribution of hash codes.
            There is nothing particularly special about 397 that distinguishes it from other primes of the same magnitude.
            </summary>
            <returns>Integer to represent instance's hashcode</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.Xuid">
            <Summary>
            Xuid
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.DelegationToken">
            <Summary>
            DelegationToken
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.Subject">
            <Summary>
            Subject
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.SpartanClaims">
            <Summary>
            SpartanClaims
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.Flags">
            <Summary>
            Special claims from Halo
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.Gamertag">
            <Summary>
            Gamertag
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.PlayerIdentity.Schema">
            <summary>
            Meta schema.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaimConfiguration.Configs">
            <summary>
            Key is the short type, and value is the configuration for this type
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase.CreateToken(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Tokens.SecurityTokenDescriptor)">
            <summary>
            Create a token from a <see cref="T:System.Security.Claims.ClaimsPrincipal"/> and a <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor"/>
            
            Note, this method is not inherited from <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler"/> as the CreateToken method in base 
            class only takes a <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor"/>, which doesn't have enough information for use to 
            create a SpartanToken. JWX is actually doing similar thing.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase.Config">
            <summary>
            Configuration used to produce or parse the token
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase.CanValidateToken">
            <summary>
            Gets a value that indicates whether the handler supports validation of security tokens.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase.CanWriteToken">
            <summary>
            Gets a value that indicates whether the handler can serialize security tokens.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase.SupportedSpartanTokenVersion">
            <summary>
            Get the supported spartan token version.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase.SupportedXstsTokenVersionForSpartanTokenCreation">
            <summary>
            Get the supported xsts token version, which is used for SpartanToken creation
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.GetTokenTypeIdentifiers">
            <summary>
            Gets the identifier for token
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.CanReadToken(System.String)">
            <summary>
            Gets a value that indicates whether the handler can read the token string
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.CanReadToken(System.Xml.XmlReader)">
            <summary>
            Gets a value that indicates whether the handler can read the token string
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.ReadToken(System.String)">
            <summary>
            Read the token string and turn it into a <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.ReadToken(System.Xml.XmlReader)">
            <summary>
            Read the token string and turn it into a <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)">
            <summary>
            Validate the security token and turn it into a collection of <see cref="T:System.Security.Claims.ClaimsIdentity"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.CreateToken(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Tokens.SecurityTokenDescriptor)">
            <summary>
            Create a token from a <see cref="T:System.Security.Claims.ClaimsPrincipal"/> and a <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.WriteToken(System.IdentityModel.Tokens.SecurityToken)">
            <summary>
            Serializes the specified security token to a string.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.TokenType">
            <summary>
            Gets the type for the token
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.SupportedSpartanTokenVersion">
            <summary>
            Get the supported token version.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV2Handler.SupportedXstsTokenVersionForSpartanTokenCreation">
            <summary>
            Get the supported xsts token version.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.GetTokenTypeIdentifiers">
            <summary>
            Gets the identifier for token
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.CanReadToken(System.String)">
            <summary>
            Gets a value that indicates whether the handler can read the token string
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.CanReadToken(System.Xml.XmlReader)">
            <summary>
            Gets a value that indicates whether the handler can read the token string
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.ReadToken(System.String)">
            <summary>
            Read the token string and turn it into a <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.ReadToken(System.Xml.XmlReader)">
            <summary>
            Read the token string and turn it into a <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.ValidateToken(System.IdentityModel.Tokens.SecurityToken)">
            <summary>
            Validate the security token and turn it into a collection of <see cref="T:System.Security.Claims.ClaimsIdentity"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.CreateToken(System.Security.Claims.ClaimsPrincipal,System.IdentityModel.Tokens.SecurityTokenDescriptor)">
            <summary>
            Create a token from a <see cref="T:System.Security.Claims.ClaimsPrincipal"/> and a <see cref="T:System.IdentityModel.Tokens.SecurityTokenDescriptor"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.WriteToken(System.IdentityModel.Tokens.SecurityToken)">
            <summary>
            Serializes the specified security token to a string.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.TokenType">
            <summary>
            Gets the type for token
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.SupportedSpartanTokenVersion">
            <summary>
            Get the supported token version.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenV3Handler.SupportedXstsTokenVersionForSpartanTokenCreation">
            <summary>
            Get the supported xsts token version.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenPartsV3.TryParse(System.String,Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenPartsV3@)">
            <summary>
            Parse the full spartan token string into 3 pieces: version, subject, and encrypted part.
            </summary>
            <param name="fullString">Something like: v3=U:0CAuxyWq;C612wwAgs..</param>
            <param name="tokenPartsV3">Parsed object of type TokenParts</param>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3">
            <Summary>
            TokenV3
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.Create(System.Collections.Generic.IEnumerable{System.Security.Claims.ClaimsIdentity},System.DateTime,Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenVersion,Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaimConfiguration)">
            <summary>
            Given claims from XSTS v3 and create an object of TokenV3. Step 1 of token minting.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.GenerateEncryptedToken(System.Byte[],System.IO.Compression.CompressionLevel)">
            <summary>
            Generate the encrypted part of the token string.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.DeserializeBondFileCompactBinary``1(System.Byte[],System.UInt16)">
            <summary>
            Copied from BondHelper and changed version to 2
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.SerializeBondObjCompactBinary``1(``0,System.UInt16)">
            <summary>
            Copied from BondHelper and changed version to 2
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.Reset">
            <Summary>
            Reset instance and re-initialize the members.
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.GetHashCode">
            <summary>
            Calculating hash code using next formula
            for each property
            result = (result * 397) ^ [property's hash code];
            397 is a prime of sufficient size to cause the result variable to overflow 
            and mix the bits of the hash somewhat, providing a better distribution of hash codes.
            There is nothing particularly special about 397 that distinguishes it from other primes of the same magnitude.
            </summary>
            <returns>Integer to represent instance's hashcode</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.Expiration">
            <Summary>
            Expiration
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.TitleIdentity">
            <Summary>
            TitleIdentity
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.Sandbox">
            <Summary>
            Sandbox
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.PlayerIdentities">
            <Summary>
            PlayerIdentities
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.DeviceIdentity">
            <Summary>
            DeviceIdentity
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.ServiceIdentity">
            <Summary>
            ServiceIdentity
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenV3.Schema">
            <summary>
            Meta schema.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory">
            <summary>
            Factory for creating common <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> configurations
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.CreateJwtTokenParser">
            <summary>
            Creates a JWT XToken <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> using the default <see cref="T:System.IdentityModel.Tokens.JwtSecurityTokenHandler"/> configuration
            </summary>
            <exception cref="T:System.InvalidOperationException">
            is thrown if there is no default configuration available for the <see cref="T:System.IdentityModel.Tokens.JwtSecurityTokenHandler"/>
            </exception>
            <returns>A configured JWT XToken <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.CreateJwtTokenParser(System.IdentityModel.Tokens.TokenValidationParameters)">
            <summary>
            Creates a JWT XToken <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> using the specified validation parameters. This
            overload does not require a valid <see cref="P:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.IdentityConfiguration"/>.
            </summary>
            <param name="parameters">The token validation parameters</param>
            <returns>A configured JWT XToken <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.CreateJwtTokenParser(System.IdentityModel.Tokens.JwtSecurityTokenHandler)">
            <summary>
            Creates a JWT XToken <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> using the specified token handler
            </summary>
            <param name="tokenHandler">The <see cref="T:System.IdentityModel.Tokens.JwtSecurityTokenHandler"/> handler to use when parsing the token</param>
            <returns>A configured JWT XToken <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.GetConfiguredJwtTokenHandler">
            <summary>
            Gets the configured XToken <see cref="T:System.IdentityModel.Tokens.JwtSecurityTokenHandler"/> specified in the <see cref="P:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.IdentityConfiguration"/>
            </summary>
            <returns>The configured JWT XToken <see cref="T:System.IdentityModel.Tokens.JwtSecurityTokenHandler"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory"/> class
            </summary>
            <remarks>
            This factory will use the default <see cref="T:System.IdentityModel.Configuration.IdentityConfiguration"/> instance
            </remarks>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory"/> class that reads from
            the <see cref="T:System.IdentityModel.Configuration.IdentityConfiguration"/>
            with the specified <paramref name="identityConfigurationName"/>.
            </summary>
            <param name="identityConfigurationName">The name of the configuration element to use</param>
            <exception cref="T:System.InvalidOperationException">
            is thrown if an identity configuration section with the specified name doesn't exist
            </exception>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.GetConfiguredTokenHandler``1">
            <summary>
            Gets the configured token handler specified in the <see cref="P:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.IdentityConfiguration"/>
            </summary>
            <returns>The configured token handler or <c>null</c></returns>
            <typeparam name="T">The token handler type</typeparam>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.GetConfiguredTokenParser``1">
            <summary>
            Creates a <see cref="T:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser"/> using the configured token handler specified in the <see cref="P:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.IdentityConfiguration"/>
            </summary>
            <typeparam name="T">The token handler type</typeparam>
            <exception cref="T:System.InvalidOperationException">
            is thrown if there is no default configuration available for the given handler type
            </exception>
            <returns>A configured <see cref="T:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.GetConfiguredTokenParser``1(System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser"/> using the configured token handler specified in the <see cref="P:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.IdentityConfiguration"/>
            </summary>
            <param name="name">Friendly name of the token parser</param>
            <typeparam name="T">The token handler type</typeparam>
            <exception cref="T:System.InvalidOperationException">
            is thrown if there is no default configuration available for the given handler type
            </exception>
            <returns>A configured <see cref="T:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.CreateXstsTokenParser">
            <summary>
            Creates an XSTS <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> using the default identity configuration
            </summary>
            <exception cref="T:System.InvalidOperationException">
            is thrown if there is no default identity configuration available
            </exception>
            <returns>A configured XSTS <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.CreateXstsTokenParser(System.String,System.String,System.Uri,System.Security.Cryptography.X509Certificates.StoreName,System.Security.Cryptography.X509Certificates.StoreLocation,System.Boolean)">
            <summary>
            Creates an XSTS <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> using the specified settings
            </summary>
            <param name="xboxLiveIssuerThumbprint">The Xbox Live service thumbprint</param>
            <param name="xboxLiveIssuerName">The name of the Xbox Live issuer</param>
            <param name="audienceUri">The token audience uri</param>
            <param name="certificateStoreName">The name of the X509 certificate store to use in token resolution</param>
            <param name="certificateStoreLocation">The location of the X509 certificate store to use in token resolution</param>
            <param name="ignoreCertificateChain">
            A value that indicates whether to ignore Certificate chain errors when validating XSTS tokens
            </param>
            <returns>A configured XSTS <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.CreateXstsTokenParser(System.IdentityModel.Tokens.Saml2SecurityTokenHandler)">
            <summary>
            Creates an XSTS <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> using the specified token handler
            </summary>
            <param name="tokenHandler">The <see cref="T:System.IdentityModel.Tokens.Saml2SecurityTokenHandler"/> handler to use when parsing the token</param>
            <returns>A configured XSTS <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.CreateConfiguredIssuer(System.String,System.String)">
            <summary>
            Creates the configured issuer.
            </summary>
            <param name="issuerThumbprint">The issuer thumbprint</param>
            <param name="issuerName">Name of the issuer</param>
            <returns>
            An <see cref="T:System.IdentityModel.Tokens.IssuerNameRegistry"/> populated with the specified <paramref name="issuerThumbprint"/> and <paramref name="issuerName"/>
            </returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.IdentityConfiguration">
            <summary>
            Gets an initialized instance of the default <see cref="P:Microsoft.Studios.StudiosNebula.Security.TokenParserFactory.IdentityConfiguration"/>
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SecurityEventSource">
            <summary>
            The <see cref="T:Microsoft.Studios.StudiosNebula.Tracing.EventSource"/> for traces produced by the Security library
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SecurityEventSource.Log">
            <summary>
            Returns a singleton instance of this class.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Base64Url">
            <summary>
            Enocder/Decoder for Base64Url
            Ref: https://secure.wikimedia.org/wikipedia/en/wiki/Base64#URL_applications
            </summary>
            <remarks>
                Namespace and method names copied from System.Text.Encoding.  Too lazy to subclass <see cref="T:System.Text.Encoding"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Base64Url.GetString(System.Byte[])">
            <summary>
            Encode binary data using a modified form of base64 known as base64url. 
            In base64url, the '+' character has been replaced a '-', the '/' with a '_', and the '=' used as padding has been eliminated.
            Ref: https://secure.wikimedia.org/wikipedia/en/wiki/Base64#URL_applications
            </summary> 
            <param name="input">The input bytes to be encoded.</param>
            <returns>The Base64Url encoded string.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Base64Url.ConvertBase64ToBase64Url(System.String)">
            <summary>
            Encode string data using a modified form of base64 known as base64url. 
            In base64url, the '+' character has been replaced a '-', the '/' with a '_', and the '=' used as padding has been eliminated.
            Ref: https://secure.wikimedia.org/wikipedia/en/wiki/Base64#URL_applications
            </summary> 
            <param name="input">The input string to be encoded.</param>
            <returns>The Base64Url encoded string.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Base64Url.GetBytes(System.String)">
            <summary>
            Decode a base64url encoded string, returning the original binary data.
            </summary>
            <param name="input">The encoded input.</param>
            <returns>The original array of bytes.</returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ISpartanTokenConfig">
            <summary>
            Configuration used to encrypt and decrypt spartan tokens
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ISpartanTokenConfig.PrimaryKeyBytes">
            <summary>
            Gets the primary encryption key
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ISpartanTokenConfig.SecondaryKeyBytes">
            <summary>
            Gets the secondary encryption key
            </summary>
            <remarks>
            This is only used when there is a problem with the primary key
            </remarks>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ISpartanTokenConfig.ReturnTitleClaimInToken">
            <summary>
            Gets a value that indicates whether the title claim should be returned in the token
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenConfig">
            <summary>
            Simple <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ISpartanTokenConfig"/> implementation
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenConfig"/> class
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenConfig.PrimaryEncryptionKey">
            <summary>
            Gets or sets the primary encryption key
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenConfig.SecondaryEncryptionKey">
            <summary>
            Gets or sets the secondary encryption key
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenConfig.IncludeTitleClaim">
            <summary>
            Gets or sets a value that indicates whether the title claim should be included in the token
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenParser">
            <summary>
            <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> implementation that delegates parsing to the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> class
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenParser.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenParser"/> class
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenParser.#ctor(Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer"/> class
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenParser.ReadToken(System.String)">
            <summary>
            Gets a principal for the specified token
            </summary>
            <param name="token">The token to read</param>
            <exception cref="T:System.ArgumentNullException">
            is thrown when <paramref name="token"/> is <c>null</c>
            </exception>
            <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
            is thrown when a problem occurs while processing a security token
            </exception>
            <exception cref="T:System.InvalidOperationException">
            is thrown when a token cannot be read using the current configuration
            </exception>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer">
            <summary>
            <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenProducer"/> implementation that delegates token creation to the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> class
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer.#ctor(System.Collections.Generic.IEnumerable{Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase})">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer"/> class
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer.#ctor(Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenHandlerBase)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer"/> class
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer.CreateToken(System.Security.Claims.ClaimsPrincipal,Microsoft.Studios.StudiosNebula.Security.SpartanToken.TokenVersion,Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenVersion,System.Nullable{System.DateTime})">
            <summary>
            Gets a token for the specified principal
            </summary>
            <param name="principal">The principal to get a token for</param>
            <param name="xstsVersion">The version of xsts, which is the source of the principal</param>
            <param name="mintVersion">The version of token caller request to mint.</param>
            <param name="expiration">
            The expiration date of the token. When this value is <c>null</c>, a default expiration is used.
            </param>
            <returns>A token for the specified principal
            Note: a SpartanToken object is returned instead of just the string is because RegisterClient 
            need extra info in the get spartan token response such as subject.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            is thrown when <paramref name="principal"/> is <c>null</c>
            </exception>
            <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
            is thrown when a problem occurs while processing a security token
            </exception>
            <exception cref="T:System.InvalidOperationException">
            is thrown when a token cannot be created using the current configuration
            </exception>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenProducer.Min(System.DateTime,System.DateTime)">
            <summary>
            Returns the smaller of two <see cref="T:System.DateTime"/>.
            </summary>
            <param name="val1">The first of two <see cref="T:System.DateTime"/>s to compare.</param>
            <param name="val2">The second of two <see cref="T:System.DateTime"/>s to compare.</param>
            <returns>
            Parameter val1 or val2, whichever is smaller.
            </returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token">
            <summary>
            The Spartan Token contract.
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.ClaimKeyXuid">
            <summary>
            Claim type for a Xuid
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.ClaimKeyGamertag">
            <summary>
            Claim type for a Gamertag
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.ClaimKeyDelegationToken">
            <summary>
            Claim type for a Delegation Token
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.TokenParser">
            <summary>
            The regular expression used to parse the token body
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> class
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.TokenBody(System.Boolean)">
            <summary>
            Returns the body for the token
            </summary>
            <param name="includeTitleClaim">Whether to include the title claim in the token</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.Parse(System.String,System.Byte[],System.Byte[],System.Boolean)">
            <summary>
            Converts the specified spring representation of a Spartan Token to its <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> equivalent.
            </summary>
            <param name="token">A string containing a spartan token to convert.</param>
            <param name="primaryKey">The primary key used to parse the token</param>
            <param name="secondaryKey">The secondary key used to parse the token; this key is optional</param>
            <param name="ignoreExpiredToken">A value that indicates whether to ignore token expiry</param>
            <returns>A <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> equivalent to the spartan token contained in <paramref name="token"/></returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="token"/> or <paramref name="primaryKey"/> is null or empty.</exception>
            <exception cref="T:System.FormatException"><paramref name="token"/> does not contain a valid string representation of a spartan token.</exception>
            <remarks>Should be in the format "v1=xuid|gamertag|delegationToken|expiration|signature"</remarks>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.GenerateEncryptedToken(System.Byte[],System.Boolean)">
            <summary>
            Generates an encrypted token for the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> using the specified key
            </summary>
            <param name="spartanTokenKey">The encryption key</param>
            <param name="includeTitleClaim">Whether to include the title claim in the token</param>
            <returns>An encrypted token</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.Create(System.Collections.Generic.IEnumerable{System.Security.Claims.Claim},System.DateTime,Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenVersion)">
            <summary>
            Creates a <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> from the specified claims
            </summary>
            <param name="xstsClaims">The claims for the token</param>
            <param name="expiration">The expiration for the token</param>
            <param name="xstsVersion">The version of xsts token</param>
            <returns>A <see cref="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token"/> with the specified claims</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.TryConvertHexStringToByteArray(System.String,System.Boolean@,System.Byte[]@)">
            <summary>
            Converts the hex string to a byte array. A return value indicates whether the conversion succeeded.
            </summary>
            <param name="hexString">The array to convert</param>
            <param name="isZeroPrepended">Whether the string is zero-prepended</param>
            <param name="bytes">A byte array for the string</param>
            <returns>true if hexString was converted successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.ByteArrayToHexString(System.Byte[])">
            <summary>
            Converts the byte array to a hex string
            </summary>
            <param name="bytes">The array to convert</param>
            <returns>A hex string for the array</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.Equals(Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token)">
            <summary>
            Two tokens are equal if they match all parameters other than expiration date
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.Equals(System.Object)">
            <summary>
            Returns whether the object is equal to the token
            </summary>
            <param name="obj">The object to compare to the token</param>
            <returns>Whether the objects are equal</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.GetHashCode">
            <summary>
            Returns the hash code for the token
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.IsHexDigit(System.Char)">
            <summary>
            Determines whether a specified character is a valid hexadecimal digit.
            </summary>
            <param name="ch">The character to validate.</param>
            <returns>true if the character is a valid hexadecimal digit; otherwise false.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.GetDelegationTokenVersion">
            <summary>
            Convert flags to the version of delegation token which will be used by Claims generated by SpartanToken
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.Xuid">
            <summary>
            Gets or sets the xuid.
            </summary>
            <value>
            The xuid.
            </value>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.Gamertag">
            <summary>
            Gets or sets the gamer tag.
            </summary>
            <value>
            The gamer tag.
            </value>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.DelegationToken">
            <summary>
            Gets or sets the delegation token.
            </summary>
            <value>
            The delegation token.
            </value>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.Expiration">
            <summary>
            Gets or sets the expiration.
            </summary>
            <value>
            The expiration.
            </value>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.TitleClaim">
            <summary>
            Gets of sets the Title Id Claim
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.Token.UgcViewAllowed">
            <summary>
            Gets or sets the UGC privileges allowed
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.UgcViewAllowedPrivilege">
            <summary>
            UGC privileges supported by the spartan token
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.UgcViewAllowedPrivilege.Everyone">
            <summary>
            The user can view all UGC
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.UgcViewAllowedPrivilege.Friends">
            <summary>
            The user can view friends' UGC
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.UgcViewAllowedPrivilege.None">
            <summary>
            The user cannot view UGC
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser">
            <summary>
            <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> implementation that delegates parsing to a <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser.#ctor(System.IdentityModel.Tokens.SecurityTokenHandler)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser"/> class with the specified token handler
            </summary>
            <param name="tokenHandler">The <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler"/> handler to use when parsing the token</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser.ReadToken(System.String)">
            <summary>
            Gets a principal for the specified token
            </summary>
            <param name="token">The token to read</param>
            <returns>A principal for the specified token</returns>
            <exception cref="T:System.ArgumentNullException">
            is thrown when <paramref name="token"/> is <c>null</c>
            </exception>
            <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
            is thrown when a problem occurs while processing a security token
            </exception>
            <exception cref="T:System.InvalidOperationException">
            is thrown when a token cannot be read using the current configuration
            </exception>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser.ReadTokenCore(System.String)">
            <summary>
            Delegates reading the token to the <see cref="T:System.IdentityModel.Tokens.SecurityTokenHandler"/>
            </summary>
            <param name="token">The token to read</param>
            <returns>A <see cref="T:System.IdentityModel.Tokens.SecurityToken"/> for the specified <paramref name="token"/></returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser.Name">
            <summary>
            Gets or sets the friendly name of the token parser
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SecurityTokenParser.TokenHandler">
            <summary>
            Gets the token handler used when parsing the token
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.TokenProducer">
            <summary>
            Abstract base class for creating authentication tokens
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenProducer.CreateToken(System.Security.Claims.ClaimsPrincipal,System.Nullable{System.DateTime})">
            <summary>
            Gets a token for the specified principal
            </summary>
            <param name="principal">The principal to get a token for</param>
            <param name="expiration">
            The expiration date of the token. When this value is <c>null</c>, a default expiration is used.
            </param>
            <returns>A token for the specified principal</returns>
            <exception cref="T:System.ArgumentNullException">
            is thrown when <paramref name="principal"/> is <c>null</c>
            </exception>
            <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
            is thrown when a problem occurs while processing a security token
            </exception>
            <exception cref="T:System.InvalidOperationException">
            is thrown when a token cannot be created using the current configuration
            </exception>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.TokenScrubber">
            <summary>
            Utility class to scrub PII out of authentication tokens
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.TokenScrubber.Scrub(System.String)">
            <summary>
            Returns a represenation of the token with all the PII scrubbed out. This must be used for all
            diagnostic information captured about a token.
            </summary>
            <param name="token">The token to scrub</param>
            <returns>A representation of the token scrubbed of PII</returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenParser">
            <summary>
            <see cref="T:Microsoft.Studios.StudiosNebula.Security.TokenParser"/> implementation for XSTS Tokens
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenParser.#ctor">
            <summary>
            Creates a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenParser"/> class using default <see cref="T:System.IdentityModel.Configuration.IdentityConfiguration"/>
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenParser.#ctor(System.IdentityModel.Configuration.IdentityConfiguration)">
            <summary>
            Creates a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenParser"/> class using the specified identity configuration
            </summary>
            <param name="identityConfiguration">The IdentityConfiguration to use</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.Xsts.XstsTokenParser.ReadToken(System.String)">
            <summary>
            Gets a principal for the specified token
            </summary>
            <param name="token">The token to read</param>
            <returns>A principal for the specified token</returns>
            <exception cref="T:System.ArgumentNullException">
            is thrown when <paramref name="token"/> is <c>null</c>
            </exception>
            <exception cref="T:System.IdentityModel.Tokens.SecurityTokenException">
            is thrown when a problem occurs while processing a security token
            </exception>
            <exception cref="T:System.InvalidOperationException">
            is thrown when a token cannot be read using the current configuration
            </exception>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceType">
            <Summary>
            TODO: Are these name exactly same as XSTS? It seems like device type is a string in XSTS. Using string now..
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenFlags">
            <Summary>
            TODO: how can we set [Flags] here.. TODO: future change to support more (all) privileges
            </Summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenFlags.AllowAllUgc">
            <Summary>
            Xbox 360: 246 XPRIVILEGE_USER_CREATED_CONTENT_FRIENDS_ONLY
            </Summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanTokenFlags.DelegationTokenPrependedZero">
            <Summary>
            Xbox 360: 247 XPRIVILEGE_USER_CREATED_CONTENT, Xbox One: 247 AuthPrivileges.UserCreatedContent
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaim">
            <Summary>
            SpartanClaim
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaim.Reset">
            <Summary>
            Reset instance and re-initialize the members.
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaim.GetHashCode">
            <summary>
            Calculating hash code using next formula
            for each property
            result = (result * 397) ^ [property's hash code];
            397 is a prime of sufficient size to cause the result variable to overflow 
            and mix the bits of the hash somewhat, providing a better distribution of hash codes.
            There is nothing particularly special about 397 that distinguishes it from other primes of the same magnitude.
            </summary>
            <returns>Integer to represent instance's hashcode</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaim.ShortType">
            <Summary>
            ShortType
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaim.Value">
            <Summary>
            Value
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.SpartanClaim.Schema">
            <summary>
            Meta schema.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceIdentity">
            <Summary>
            DeviceIdentity
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceIdentity.#ctor">
            <Summary>
            TODO: is this HexBinary from XSTS? Further optimization? Also which XSTS claim should we use
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceIdentity.Reset">
            <Summary>
            Reset instance and re-initialize the members.
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceIdentity.GetHashCode">
            <summary>
            Calculating hash code using next formula
            for each property
            result = (result * 397) ^ [property's hash code];
            397 is a prime of sufficient size to cause the result variable to overflow 
            and mix the bits of the hash somewhat, providing a better distribution of hash codes.
            There is nothing particularly special about 397 that distinguishes it from other primes of the same magnitude.
            </summary>
            <returns>Integer to represent instance's hashcode</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceIdentity.DeviceId">
            <Summary>
            DeviceId
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceIdentity.DeviceType">
            <Summary>
            TODO: is this HexBinary from XSTS? Further optimization? Also which XSTS claim should we use
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.DeviceIdentity.Schema">
            <summary>
            Meta schema.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TitleIdentity">
            <Summary>
            TitleIdentity
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TitleIdentity.Reset">
            <Summary>
            Reset instance and re-initialize the members.
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TitleIdentity.GetHashCode">
            <summary>
            Calculating hash code using next formula
            for each property
            result = (result * 397) ^ [property's hash code];
            397 is a prime of sufficient size to cause the result variable to overflow 
            and mix the bits of the hash somewhat, providing a better distribution of hash codes.
            There is nothing particularly special about 397 that distinguishes it from other primes of the same magnitude.
            </summary>
            <returns>Integer to represent instance's hashcode</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TitleIdentity.TitleId">
            <Summary>
            TitleId
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.TitleIdentity.Schema">
            <summary>
            Meta schema.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceClaim">
            <Summary>
            ServiceClaim
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceClaim.Reset">
            <Summary>
            Reset instance and re-initialize the members.
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceClaim.GetHashCode">
            <summary>
            Calculating hash code using next formula
            for each property
            result = (result * 397) ^ [property's hash code];
            397 is a prime of sufficient size to cause the result variable to overflow 
            and mix the bits of the hash somewhat, providing a better distribution of hash codes.
            There is nothing particularly special about 397 that distinguishes it from other primes of the same magnitude.
            </summary>
            <returns>Integer to represent instance's hashcode</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceClaim.Type">
            <Summary>
            Type
            </Summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceClaim.Value">
            <Summary>
            Value
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceClaim.Schema">
            <summary>
            Meta schema.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceIdentity">
            <Summary>
            ServiceIdentity
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceIdentity.Reset">
            <Summary>
            Reset instance and re-initialize the members.
            </Summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceIdentity.GetHashCode">
            <summary>
            Calculating hash code using next formula
            for each property
            result = (result * 397) ^ [property's hash code];
            397 is a prime of sufficient size to cause the result variable to overflow 
            and mix the bits of the hash somewhat, providing a better distribution of hash codes.
            There is nothing particularly special about 397 that distinguishes it from other primes of the same magnitude.
            </summary>
            <returns>Integer to represent instance's hashcode</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceIdentity.ServiceClaims">
            <Summary>
            ServiceClaims
            </Summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Security.SpartanToken.ServiceIdentity.Schema">
            <summary>
            Meta schema.
            </summary>
        </member>
    </members>
</doc>
