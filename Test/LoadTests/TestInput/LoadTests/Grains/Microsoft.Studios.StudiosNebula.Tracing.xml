<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Studios.StudiosNebula.Tracing</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventProvider">
            <summary>
            Only here because System.Diagnostics.EventProvider needs one more extensibility hook (when it gets a 
            controller callback)
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.#ctor(System.Guid)">
            <summary>
            Constructs a new EventProviderClone.  This causes the class to be registered with the OS an
            if a ETW controller turns on the logging then logging will start. 
            </summary>
            <param name="providerGuid">The GUID that identifies this provider to the system.</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.Register(System.Guid)">
            <summary>
            This method registers the controlGuid of this class with ETW.
            We need to be running on Vista or above. If not an 
            PlatformNotSupported exception will be thrown. 
            If for some reason the ETW Register call failed
            a NotSupported exception will be thrown. 
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.Close">
            <summary>
            This method deregisters the controlGuid of this class with ETW.
            
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.Deregister">
            <summary>
            This method un-registers from ETW.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.GetDataFromController(Microsoft.Studios.StudiosNebula.Tracing.EventProvider.ManifestEtw.EVENT_FILTER_DESCRIPTOR*,Microsoft.Studios.StudiosNebula.Tracing.ControllerCommand@,System.Byte[]@,System.Int32@)">
            <summary>
            Gets any data to be passed from the controller to the provider.  It starts with what is passed
            into the callback, but unfortunately this data is only present for when the provider is active
            at the the time the controller issues the command.  To allow for providers to activate after the
            controller issued a command, we also check the registry and use that to get the data.  The function
            returns an array of bytes representing the data, the index into that byte array where the data
            starts, and the command being issued associated with that data.  
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.IsEnabled">
            <summary>
            IsEnabled, method used to test if provider is enabled
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.IsEnabled(System.Byte,System.Int64)">
            <summary>
            IsEnabled, method used to test if event is enabled
            </summary>
            <param name="level">
            Level  to test
            </param>
            <param name="keywords">
            Keyword  to test
            </param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Object[])">
            <summary>
            WriteEvent, method to write a parameters with event schema properties
            </summary>
            <param name="eventDescriptor">
            Event Descriptor for this event. 
            </param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.String)">
            <summary>
            WriteEvent, method to write a string with event schema properties
            </summary>
            <param name="eventDescriptor">
            Event Descriptor for this event. 
            </param>
            <param name="data">
            string to log. 
            </param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventProvider.WriteEvent(System.Diagnostics.Eventing.EventDescriptor@,System.Int32,System.IntPtr)">
            <summary>
            WriteEvent, method to be used by generated code on a derived class
            </summary>
            <param name="eventDescriptor">
            Event Descriptor for this event. 
            </param>
            <param name="dataCount">
            number of event descriptors 
            </param>
            <param name="data">
            pointer  do the event data
            </param>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventSource">
            <summary>
            This class is meant to be inherited by a user curEventSource (which provides specific events and then
            calls code:EventSource.WriteEvent to log them).   
            
            sealed class MinimalEventSource : EventSource
            {
                * public void Load(long ImageBase, string Name) { WriteEvent(1, ImageBase, Name); }
                * public void Unload(long ImageBase) { WriteEvent(2, ImageBase); }
                * private MinimalEventSource() {}
            }
            
            This functionaity is sufficient for many users.   When more control is needed over the ETW manifest
            that is created, that can be done by adding [Event] attributes on the  methods.
            
            Finally for very advanced EventSources, it is possible to intercept the commands being given to the
            curEventSource and change what filtering is done (or cause actions to be performed by the curEventSource (eg
            dumping a data structure).  
            
            The eventSources can be turned on with Window ETW controllers (eg logman), immediately.  It is also
            possible to control and intercept the data dispatcher programatically.  We code:EventListener for
            more.      
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.IsEnabled">
            <summary>
            Returns true if the curEventSource has been enabled at all.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.IsEnabled(Microsoft.Studios.StudiosNebula.Tracing.EventLevel,Microsoft.Studios.StudiosNebula.Tracing.EventKeywords)">
            <summary>
            Returns true if events with >= 'level' and have one of 'keywords' set are enabled. 
            
            Note that the result of this function only an approximiation on whether a particular event is
            active or not.  It is only meant to be use as way of avoiding expensive
            computation for logging when logging is not on.   EventSources are free to have additional
            filtering.    
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.GenerateManifest(System.Type,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Returns a string of the XML manifest associated with the curEventSource. The scheme for this XML is
            documented at in EventManifest Schema http://msdn.microsoft.com/en-us/library/aa384043(VS.85).aspx
            </summary>
            <param name="assemblyPathToIncludeInManifest">The manifest XML fragment contains the string name of the DLL name in
            which it is embeded.  This parameter spcifies what name will be used</param>
            <returns>The XML data string</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.OnEventCommand(Microsoft.Studios.StudiosNebula.Tracing.EventCommandEventArgs)">
            <summary>
            This method is called when the curEventSource is updated by the controller.  
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.Dispose(System.Boolean)">
            <summary>
            Disposes of an EventSource.
            </summary>
            <remarks>
            Called from Dispose() with disposing=true, and from the finalizer (~MeasurementBlock) with disposing=false.
            Guidelines:
            1. We may be called more than once: do nothing after the first call.
            2. Avoid throwing exceptions if disposing is false, i.e. if we're being finalized.
            </remarks>
            <param name="disposing">True if called from Dispose(), false if called from the finalizer.</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.IsEnabledByDefault(System.Int32,System.Boolean,Microsoft.Studios.StudiosNebula.Tracing.EventLevel,Microsoft.Studios.StudiosNebula.Tracing.EventKeywords)">
            <summary>
            Returns true if 'eventNum' is enabled if you only consider the level and matchAnyKeyword filters.
            It is possible that eventSources turn off the event based on additional filtering criteria.  
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.SendCommand(Microsoft.Studios.StudiosNebula.Tracing.EventSource,Microsoft.Studios.StudiosNebula.Tracing.EventCommand,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Send a command to a particular EventSource identified by 'eventSource'
            
            Calling this routine simply forwards the command to the EventSource.OnEventCommand
            callback.  What the EventSource does with the command and its arguments are from that point
            EventSource-specific.  
            
            The curEventSource is passed the EventListener that issued the command allong with the command and
            arguments.   The contract is that to the extent possible the curEventSource should not affect other
            EventListeners (eg filtering events), however sometimes this simply is not possible (if the
            command was to provoke a GC, or a System flush etc).   
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.EnableEventForDispatcher(Microsoft.Studios.StudiosNebula.Tracing.EventDispatcher,System.Int32,System.Boolean)">
            <summary>
            If 'value is 'true' then set the curEventSource so that 'dispatcher' will recieve event with the eventId
            of 'eventId.  If value is 'false' disable the event for that dispatcher.   If 'eventId' is out of
            range return false, otherwise true.  
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.AnyEventEnabled">
            <summary>
            Returns true if any event at all is on.  
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventSource.GetHelperCallFirstArg(System.Reflection.MethodInfo)">
            <summary>
            This method looks at the IL and tries to pattern match against the standard
            'boilerplate' event body 
            
                { if (Enabled()) WriteEvent(#, ...) } 
            
            If the pattern matches, it returns the literal number passed as the first parameter to
            the WriteEvent.  This is used to find common user errors (mismatching this
            number with the EventAttribute ID).  It is only used for validation.   
            </summary>
            <param name="method">The method to probe.</param>
            <returns>The literal value or -1 if the value could not be determined. </returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Tracing.EventSource.Name">
            <summary>
            The human-friendly name of the curEventSource.  It defaults to the simple name of the class
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Tracing.EventSource.Guid">
            <summary>
            Every curEventSource is assigned a GUID to uniquely identify it to the system. 
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Tracing.EventSource.ConstructionException">
            <summary>
            Because
            
                1) Logging is often optional and thus should not generate fatal errors (exceptions)
                2) EventSources are often initialized in class constructors (which propagate exceptions poorly)
                
            The event source constructor does not throw exceptions.  Instead we remember any exception that 
            was generated (it is also logged to Trace.WriteLine).
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Tracing.EventSource.LastCommandException">
            <summary>
            Provider commands may come from a special ETW thread that will swallow exceptions.  Thus to help
            diagnosis, we remember the last exception that was generated while a EventSource command was being
            run.  Note that because of races, this should not be used in normal programming, it is really for
            diagnostic purposes.  
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventSource.OverideEventProvider">
            <summary>
            This class lets us hook the 'OnEventCommand' from the curEventSource.  
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventSource.EventMetadata">
            <summary>
            Used to hold all the static information about an event.  This includes everything in the event
            descriptor as well as some stuff we added specifically for EventSource. see the
            code:m_eventData for where we use this.  
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventListener">
            <summary>
            An code:EventListener represents the target for all events generated by EventSources (that is
            subclasses of code:EventSource), in the currnet appdomain. When a new EventListener is created
            it is logically attached to all eventSources in that appdomain. When the EventListener is Disposed, then
            it is disconnected from the event eventSources. Note that there is a internal list of STRONG references
            to EventListeners, which means that relying on the lack of references ot EventListeners to clean up
            EventListeners will NOT work. You must call EventListener.Dispose explicitly when a dispatcher is no
            longer needed.
            
            Once created, EventListeners can enable or disable on a per-curEventSource basis using verbosity levels
            (code:EventLevel) and bitfields code:EventKeywords to further restrict the set of events to be sent
            to the dispatcher. The dispatcher can also send arbitrary commands to a particular curEventSource using the
            'SendCommand' method. The meaning of the commands are curEventSource specific.
            
            The Null Guid (that is (new Guid()) has special meaning as a wildcard for 'all current eventSources in
            the appdomain'. Thus it is relatively easy to turn on all events in the appdomain if desired.
            
            It is possible for there to be many EventListener's defined in a single appdomain. Each dispatcher is
            logically independent of the other listeners. Thus when one dispatcher enables or disables events, it
            affects only that dispatcher (other listeners get the events they asked for). It is possible that
            commands sent with 'SendCommand' would do a semantic operation that would affect the other listeners
            (like doing a GC, or flushing data ...), but this is the exception rather than the rule.
            
            Thus the model is that each EventSource keeps a list of EventListeners that it is sending events
            to. Associated with each EventSource-dispatcher pair is a set of filtering criteria that determine for
            that curEventSource what events that dispatcher will recieve.
            
            Listeners receive the events on their 'OnEventWritten' method. Thus subclasses of EventListener must
            override this method to do something useful with the data.
            
            In addition, when new eventSources are created, the 'OnEventSourceCreate' method is called. The
            invariant associated with this callback is that every curEventSource gets exactly one
            'OnEventSourceCreate' call for ever curEventSource that can potentially send it log messages. In
            particular when a EventListener is created, typically a series of OnEventSourceCreate' calls are
            made to notify the new dispatcher of all the eventSources that existed before the EventListener was
            created.
            
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.#ctor">
            <summary>
            Create a new EventListener in which all events start off truned off (use EnableEvents to turn
            them on).  
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.Dispose">
            <summary>
            Dispose should be called when the EventListener no longer desires 'OnEvent*' callbacks. Because
            there is an internal list of strong references to all EventListeners, calling 'Displose' directly
            is the only way to actually make the listen die. Thus it is important that users of EventListener
            call Dispose when they are done with their logging.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.EnableEvents(Microsoft.Studios.StudiosNebula.Tracing.EventSource,Microsoft.Studios.StudiosNebula.Tracing.EventLevel)">
             <summary>
             Enable all events from the curEventSource identified by 'eventSource' to the current dispatcher that have a
             verbosity level of 'level' or lower.
               
             This call can have the effect of REDUCING the number of events sent to the dispatcher if 'level'
             indicates a less verbose level than was previously enabled.
             
             This call never has an effect on other EventListeners.
            
             Returns 'true' if any curEventSource could be found that matches 'eventSourceGuid'
             </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.EnableEvents(Microsoft.Studios.StudiosNebula.Tracing.EventSource,Microsoft.Studios.StudiosNebula.Tracing.EventLevel,Microsoft.Studios.StudiosNebula.Tracing.EventKeywords)">
            <summary>
            Enable all events from the curEventSource identified by 'eventSourceGuid' to the current dispatcher that have a
            verbosity level of 'level' or lower and have a event keyword matching any of the bits in
            'machAnyKeyword'.
            
            This call can have the effect of REDUCING the number of events sent to the dispatcher if 'level'
            indicates a less verbose level than was previously enabled or if 'machAnyKeyword' has fewer
            keywords set than where previously set.
            
            If eventSourceGuid is Guid.Empty, then the affects all eventSources in the appdomain
            
            If eventSourceGuid is not Guid.Empty, this call has no effect on any other eventSources in the appdomain.
            
            This call never has an effect on other EventListeners.
            
            Returns 'true' if any curEventSource could be found that matches 'eventSourceGuid'        
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.EnableEvents(Microsoft.Studios.StudiosNebula.Tracing.EventSource,Microsoft.Studios.StudiosNebula.Tracing.EventLevel,Microsoft.Studios.StudiosNebula.Tracing.EventKeywords,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Enable all events from the curEventSource identified by 'eventSource' to the current dispatcher that have a
            verbosity level of 'level' or lower and have a event keyword matching any of the bits in
            'machAnyKeyword' as well as any (curEventSource specific) effect passing addingional 'key-value' arguments
            'arguments' might have.  
            
            This call can have the effect of REDUCING the number of events sent to the dispatcher if 'level'
            indicates a less verbose level than was previously enabled or if 'machAnyKeyword' has fewer
            keywords set than where previously set.
            
            This call never has an effect on other EventListeners.
            </summary>       
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.DisableEvents(Microsoft.Studios.StudiosNebula.Tracing.EventSource)">
            <summary>
            Disables all events coming from curEventSource identified by 'eventSource'.  
            
            If eventSourceGuid is Guid.Empty, then the affects all eventSources in the appdomain
            
            This call never has an effect on other EventListeners.      
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.OnEventSourceCreated(Microsoft.Studios.StudiosNebula.Tracing.EventSource)">
            <summary>
            This method is caleld whenever a new curEventSource is 'attached' to the dispatcher.
            This can happen for all existing EventSources when the EventListener is created
            as well as for any EventSources that come into existance after the EventListener
            has been created.
            
            These 'catch up' events are called during the construction of the EventListener.
            Subclasses need to be prepared for that.
            
            In a multi-threaded environment, it is possible that 'OnEventWritten' callbacks
            for a paritcular curEventSource to occur BEFORE the OnEventSourceCreated is issued.
            </summary>
            <param name="eventSource"></param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.OnEventWritten(Microsoft.Studios.StudiosNebula.Tracing.EventWrittenEventArgs)">
            <summary>
            This method is called whenever an event has been written by a EventSource for which the EventListener
            has enabled events.  
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.EventSourceIndex(Microsoft.Studios.StudiosNebula.Tracing.EventSource)">
            <summary>
            EventSourceIndex is small non-negative integer (suitable for indexing in an array)
            identifying EventSource. It is unique per-appdomain. Some EventListeners might find
            it useful to store addditional information about each curEventSource connected to it,
            and EventSourceIndex allows this extra infomation to be efficiently stored in a
            (growable) array (eg List(T)).
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.AddEventSource(Microsoft.Studios.StudiosNebula.Tracing.EventSource)">
            <summary>
            This routine adds newEventSource to the global list of eventSources, it also assigns the
            ID to the curEventSource (which is simply the oridinal in the global list).
            
            EventSources currently do not pro-actively remove themselves from this list. Instead
            when eventSources's are GCed, the weak handle in this list naturally gets nulled, and
            we will reuse the slot. Today this list never shrinks (but we do reuse entries
            that are in the list). This seems OK since the expectation is that EventSources
            tend to live for the lifetime of the appdomain anyway (they tend to be used in
            global variables).
            </summary>
            <param name="newEventSource"></param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.RemoveReferencesToListenerInEventSources(Microsoft.Studios.StudiosNebula.Tracing.EventListener)">
            <summary>
            Helper used in code:Dispose that removes any references to 'listenerToRemove' in any of the
            eventSources in the appdomain.  
            
            The EventListenersLock must be held before calling this routine. 
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.EventListener.Validate">
            <summary>
            Checks internal consistancy of EventSources/Listeners. 
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Tracing.EventListener.EventListenersLock">
            <summary>
            Gets a global lock that is intended to protect the code:s_Listeners linked list and the
            code:s_EventSources WeakReference list.  (We happen to use the s_EventSources list as
            the lock object)
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventCommandEventArgs">
            <summary>
            Passed to the code:EventSource.OnEventCommand callback
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventWrittenEventArgs">
            <summary>
            code:EventWrittenEventArgs is passed when the callback given in code:EventListener.OnEventWritten is
            fired.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Tracing.EventSourceAttribute.LocalizationResources">
            <summary>
            EventSources support localization of events.   The names used for events, opcodes, tasks, keyworks and maps 
            can be localized to several languages if desired.   This works by creating a ResX style string table 
            (by simply adding a 'Resource File' to your project).  This resource file is given a name e.g. 'DefaultNameSpace.ResourceFileName'
            which can be passed to the ResourceManager constructor to read the resoruces.  This name is the value
            of the LocalizationResources property. 
            
            LocalizationResources property is non-null, then EventSource will look up the localized strings for events by 
            using the following resource naming scheme
            
                event_EVENTNAME
                task_TASKNAME
                keyword_KEYWORDNAME
                map_MAPNAME
                
            where the capitpalized name is the name of the event, task, keywork, or map value that should be localized.   
            Note that the localized string for an event cooresponds to the Messsage string, and can have {0} values 
            which represent the payload values.  
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventAttribute">
            <summary>
            None instance methods in a class that subclasses code:EventSource that and return void are
            assumed by default to be methods that generate an event. Enough information can be deduced from the
            name of the method and its signature to generate basic schema information for the event. The
            code:EventAttribute allows you to specify additional event schema information for an event if
            desired.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Tracing.EventAttribute.Message">
            <summary>
            This is also used for TraceSource compatabilty.  If code:EventSource.TraceSourceSupport is
            on events will also be logged a tracesource with the same name as the curEventSource.  If this
            property is set then the payload will go to code:TraceSource.TraceEvent, and this string
            will be used as the message.  If this property is not set not set it goes to
            code:TraceSource.TraceData.   You can use standard .NET substitution operators (eg {1}) in 
            the string and they will be replaced with the 'ToString()' of the cooresponding part of the
            event payload.   
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.NonEventAttribute">
            <summary>
            By default all instance methods in a class that subclasses code:EventSource that and return
            void are assumed to be methods that generate an event. This default can be overriden by specifying
            the code:NonEventAttribute
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventDispatcher">
            <summary>
            code:EventDispatchers are a simple 'helper' structure that holds the filtering state
            (m_EventEnabled) for a particular EventSource X EventListener tuple
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.ManifestBuilder">
            <summary>
            ManifestBuilder is designed to isolate the details of the message of the event from the
            rest of EventSource.  This one happens to create XML. 
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Tracing.ManifestBuilder.#ctor(System.String,System.Guid,System.String,System.Resources.ResourceManager)">
            <summary>
            Build a manifest for 'providerName' with the given GUID, which will be packaged into 'dllName'.
            'resources, is a resource manager.  If specified all messsages are localized using that manager.  
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.ManifestEnvelope">
            <summary>
            Used to send the m_rawManifest into the event dispatcher as a series of events.  
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventLevel">
            <summary>
            WindowsEventLevel
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventLevel.LogAlways">
            <summary>
            Log always
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventLevel.Critical">
            <summary>
            Only critical errors
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventLevel.Error">
            <summary>
            All errors, including previous levels
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventLevel.Warning">
            <summary>
            All warnings, including previous levels
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventLevel.Informational">
            <summary>
            All informational events, including previous levels
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventLevel.Verbose">
            <summary>
            All events, including previous levels 
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventTask">
            <summary>
            WindowsEventTask
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventTask.None">
            <summary>
            Undefined task
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode">
            <summary>
            EventOpcode
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Info">
            <summary>
            An informational event
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Start">
            <summary>
            An activity start event
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Stop">
            <summary>
            An activity end event 
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.DataCollectionStart">
            <summary>
            A trace collection start event
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.DataCollectionStop">
            <summary>
            A trace collection end event
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Extension">
            <summary>
            An extensional event
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Reply">
            <summary>
            A reply event
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Resume">
            <summary>
            An event representing the activity resuming from the suspension
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Suspend">
            <summary>
            An event representing the activity is suspended, pending another activity's completion
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Send">
            <summary>
            An event representing the activity is transferred to another component, and can continue to work
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventOpcode.Receive">
            <summary>
            An event representing receiving an activity transfer from another component 
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords">
            <summary>
            EventOpcode
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.None">
            <summary>
            Wild card value
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.WdiContext">
            <summary>
            WDI context events
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.WdiDiagnostic">
            <summary>
            WDI diagnostic events
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.Sqm">
            <summary>
            SQM events
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.AuditFailure">
            <summary>
            FAiled security audits
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.AuditSuccess">
            <summary>
            Successful security audits
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.CorrelationHint">
            <summary>
            Transfer events where the related Activity ID is a computed value and not a GUID
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.EventLogClassic">
            <summary>
            Events raised using classic eventlog API
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Tracing.EventKeywords.All">
            <summary>
            Turns on everything.  
            </summary>
        </member>
    </members>
</doc>
