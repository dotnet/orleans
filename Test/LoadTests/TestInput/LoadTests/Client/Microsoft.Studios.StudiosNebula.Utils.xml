<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Studios.StudiosNebula.Utils</name>
    </assembly>
    <members>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Finally``1(System.Threading.Tasks.Task{``0},System.Action)">
            <summary>
            Simulates a finally block on a Task&lt;T&gt;, preserving the state of the initial Task./>
            </summary>
            <typeparam name="T">The type of the result produced by the c.</typeparam>
            <param name="first">The task to chain to</param>
            <param name="finallyAction">The action to execute once the first task completes.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Then(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task})">
            <summary>
            Based on code from: http://blogs.msdn.com/b/pfxteam/archive/2010/11/21/10094564.aspx
            
            Similar to Task.ContinueWith with the exception that 
            it's contiuation delegate also returns a task.
            The Task returned by is not completed until the the inner task returned 
            by the continuation is complete. This variation on ContinueWith allows the 
            asynchronous equivalent of recursion with Tasks. A task can return Completed or 
            it can return a task generated by another call to Chain
            </summary>
            <param name="first">The task to chain to</param>
            <param name="next">Delegate that returns the next task to perform</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Then``1(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Based on code from: http://blogs.msdn.com/b/pfxteam/archive/2010/11/21/10094564.aspx
            
            Similar to Task.ContinueWith with the exception that 
            it's contiuation delegate also returns a task.
            The Task returned by is not completed until the the inner task returned 
            by the continuation is complete. This variation on ContinueWith allows the 
            asynchronous equivalent of recursion with Tasks. A task can return Completed or 
            it can return a task generated by another call to Chain
            </summary>
            <param name="first">The task to chain to</param>
            <param name="next">Delegate that returns the next task to perform</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Then``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task})">
            <summary>
            Based on code from: http://blogs.msdn.com/b/pfxteam/archive/2010/11/21/10094564.aspx
            
            Similar to Task.ContinueWith with the exception that 
            it's contiuation delegate also returns a task.
            The Task returned by is not completed until the the inner task returned 
            by the continuation is complete. This variation on ContinueWith allows the 
            asynchronous equivalent of recursion with Tasks. A task can return Completed or 
            it can return a task generated by another call to Chain
            </summary>
            <param name="first">The task to chain to</param>
            <param name="next">Delegate that returns the next task to perform</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>
            Based on code from: http://blogs.msdn.com/b/pfxteam/archive/2010/11/21/10094564.aspx
            
            Similar to Task.ContinueWith with the exception that 
            it's contiuation delegate also returns a task.
            The Task returned by is not completed until the the inner task returned 
            by the continuation is complete. This variation on ContinueWith allows the 
            asynchronous equivalent of recursion with Tasks. A task can return Completed or 
            it can return a task generated by another call to Chain
            </summary>
            <param name="first">The task to chain to</param>
            <param name="next">Delegate that returns the next task to perform</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Then(System.Threading.Tasks.Task,System.Func{System.Threading.Tasks.Task}[])">
            <summary>
            Based on code from: http://blogs.msdn.com/b/pfxteam/archive/2010/11/21/10094564.aspx
            
            Similar to Task.ContinueWith with the exception that 
            it's contiuation delegate also returns a task.
            The Task returned by is not completed until the the inner task returned 
            by the continuation is complete. This variation on ContinueWith allows the 
            asynchronous equivalent of recursion with Tasks. A task can return Completed or 
            it can return a task generated by another call to Chain
            </summary>
            <param name="first">The task to chain to</param>
            <param name="next">Delegate that returns the next task to perform</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Then``1(System.Threading.Tasks.Task{``0},System.Func{``0,System.Threading.Tasks.Task}[])">
            <summary>
            Based on code from: http://blogs.msdn.com/b/pfxteam/archive/2010/11/21/10094564.aspx
            
            Similar to Task.ContinueWith with the exception that 
            it's contiuation delegate also returns a task.
            The Task returned by is not completed until the the inner task returned 
            by the continuation is complete. This variation on ContinueWith allows the 
            asynchronous equivalent of recursion with Tasks. A task can return Completed or 
            it can return a task generated by another call to Chain
            </summary>
            <param name="first">The task to chain to</param>
            <param name="next">Delegate that returns the next task to perform</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Iterate(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            Copied from http://blogs.msdn.com/b/pfxteam/archive/2010/11/21/10094564.aspx
            This Iterate method accepts an enumerable of tasks.
            </summary>
            <param name="asyncIterator">An IEnumerable of Tasks to execute</param>
            <returns>A task that is complete when all the tasks generated by the IEnumerable are done</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Begin(System.Threading.Tasks.Task,System.AsyncCallback,System.Object)">
            <summary>
            Helper function for using Tasks from the CLR's Begin/End Patttern This is useful
            when implementing the begin e/end pattern in WCF web services or in an IHttpHandler
            </summary>
            <param name="t">The task to be used in the begin/end pattern</param>
            <param name="callback">a standard AsyncCallback</param>
            <param name="state">an async state object</param>
            <remarks>This method will start executing the task if it is not already running</remarks>
            <returns>An IAsyncResult representing the executing task</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Begin(System.Func{System.Threading.Tasks.Task},System.AsyncCallback,System.Object)">
            <summary>
            Helper function for using Tasks from the CLR's Begin/End Patttern This is useful
            when implementing the begin e/end pattern in WCF web services or in an IHttpHandler
            </summary>
            <param name="t">The task to be used in the begin/end pattern</param>
            <param name="callback">a standard AsyncCallback</param>
            <param name="state">an async state object</param>
            <remarks>This method will start executing the task if it is not already running</remarks>
            <returns>An IAsyncResult representing the executing task</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.End(System.IAsyncResult)">
            <summary>
            Helper function for using Tasks from the CLR's Begin/End Patttern This is useful
            when implementing the begin e/end pattern in WCF web services or in an IHttpHandler
            </summary>
            <param name="result">The IAsyncResult that represents the asynchronous task</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Begin``1(System.Threading.Tasks.Task{``0},System.AsyncCallback,System.Object)">
            <summary>
            Helper function for using Tasks from the CLR's Begin/End Patttern This is useful
            when implementing the begin e/end pattern in WCF web services or in an IHttpHandler
            </summary>
            <param name="t">A factory method for the task to be used in the begin/end pattern</param>
            <param name="callback">a standard AsyncCallback</param>
            <param name="state">an async state object</param>
            <remarks>This method will start executing the task if it is not already running</remarks>
            <returns>An IAsyncResult representing the executing task</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.Begin``1(System.Func{System.Threading.Tasks.Task{``0}},System.AsyncCallback,System.Object)">
            <summary>
            Helper function for using Tasks from the CLR's Begin/End Patttern This is useful
            when implementing the begin e/end pattern in WCF web services or in an IHttpHandler
            </summary>
            <param name="t">A factory method for the task to be used in the begin/end pattern</param>
            <param name="callback">a standard AsyncCallback</param>
            <param name="state">an async state object</param>
            <remarks>This method will start executing the task if it is not already running</remarks>
            <returns>An IAsyncResult representing the executing task</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.End``1(System.IAsyncResult)">
            <summary>
            Helper function for using Tasks from the CLR's Begin/End Patttern This is useful
            when implementing the begin e/end pattern in WCF web services or in an IHttpHandler
            </summary>
            <param name="result">The IAsyncResult that represents the asynchronous task</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.SimpleContinueWith``2(System.Threading.Tasks.Task{``0},System.Func{System.Threading.Tasks.Task{``0},``1})">
            <summary>
            A simpler form of ContinueWith that performs the common exception handling and SyncronizationContext management which is boilerplate code in most ContinueWith blocks. 
            </summary>
            <remarks>
            This is heavily based on Brad Wilson's article at http://bradwilson.typepad.com/blog/2012/04/tpl-and-servers-pt1.html.
            </remarks>
            <typeparam name="TResult">The type of the result produced by the original task.</typeparam>
            <typeparam name="TNewResult">The type of the result produced by the continuation.</typeparam>
            <param name="task">The original task to continue from.</param>
            <param name="continuationFunction">A function to run when the initial task completes. When run, the delegate will be passed the completed task as an argument.</param>
            <returns>A new continuation of the original task.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.ContinueClosure``2(System.Threading.Tasks.Task{``0},System.Func{System.Threading.Tasks.Task{``0},``1})">
            <summary>
            Separates the closure portion of the SimpleContinueWith method from the "already completed" portion to avoid the extra allocations in cases where the
            original task was already complete.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.SimpleContinueWith``1(System.Threading.Tasks.Task,System.Func{``0})">
            <summary>
            A simpler form of ContinueWith that performs the common exception handling and SyncronizationContext management which is boilerplate code in most ContinueWith blocks. 
            </summary>
            <remarks>
            This is heavily based on Brad Wilson's article at http://bradwilson.typepad.com/blog/2012/04/tpl-and-servers-pt1.html.
            </remarks>
            <typeparam name="TNewResult">The type of the result produced by the continuation.</typeparam>
            <param name="task">The original task to continue from.</param>
            <param name="continuationFunction">A function to run when the initial task completes. When run, the delegate will be passed the completed task as an argument.</param>
            <returns>A new continuation of the original task.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.TaskHelpers.ContinueClosure``1(System.Threading.Tasks.Task,System.Func{``0})">
            <summary>
            Separates the closure portion of the SimpleContinueWith method from the "already completed" portion to avoid the extra allocations in cases where the
            original task was already complete.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.CompletedTask`1">
            <summary>
            A helper taks for Tasks that are already completed. the static singleton is useful
            for tasks that return default values.
            </summary>
            <remarks>This class is a handy wrapper around the <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> class</remarks>
            <typeparam name="T">The task result type</typeparam>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.CompletedTask`1.CreateCompleted(`0)">
            <summary>
            Creates a Completed <see cref="T:System.Threading.Tasks.Task`1"/> with the provided result
            </summary>
            <param name="result">The result to assign to the completed task</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.CompletedTask`1.CreateFaulted(System.Exception)">
            <summary>
            Creates a Faulted <see cref="T:System.Threading.Tasks.Task`1"/> with the provided exception
            </summary>
            <param name="exception">The exception to assign to the completed task</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.CompletedTask`1.CreateFaulted(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Creates a Faulted <see cref="T:System.Threading.Tasks.Task`1"/> with the provided exception
            </summary>
            <param name="exception">The exception to assign to the completed task</param>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.AsyncVoid">
            <summary>
            An empty struct to use to indicate that TaskCompletionSource is expected to have no value.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.DateTimeUtils">
            <summary>
            Provides a series of <see cref="T:System.DateTime"/> utilities and extension methods.
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Utils.DateTimeUtils.LexigraphicalFormat">
            <summary>
            The format string used to generate lexigraphically-sortable date-time strings.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.DateTimeUtils.GetLexigraphicalString(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> instance to a lexigraphically-sortable string.
            </summary>
            <param name="timestamp">The timestamp to convert.</param>
            <returns>A lexigraphically-sortable string.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.DateTimeUtils.ParseLexigraphicalString(System.String)">
            <summary>
            Parses a lexigraphically-sortable date-time string.
            </summary>
            <param name="input">The lexigraphically-sortable string to parse.</param>
            <returns>The DateTime represented by the input string.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.DateTimeUtils.TryParseLexigraphicalString(System.String,System.DateTime@)">
            <summary>
            Tries to parse a lexigraphically-sortable date-time string.
            </summary>
            <param name="input">The lexigraphically-sortable string to parse.</param>
            <param name="result">The DateTime represented by the input string on success, undefined on failure.</param>
            <returns>Whether the parse was successful.</returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.DispatcherEvents">
            <summary>
            Diagnostic events for Nebula.Diagnostics
            </summary>
            <remarks>
            It is not ideal to have this in a different assembly from the Nebula.Dispatcher assembly, but F# does not support some critical
            features (e.g. nested classes) required to fully implement an EventSource. Moving the implementation here to get around these issues.
            </remarks>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.DispatcherEvents.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Utils.DispatcherEvents"/> class from being created.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.DispatcherEvents.Log">
            <summary>
            Gets an instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Utils.DispatcherEvents"/>
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.GovernedStream">
            <summary>
            Wraps a stream and limits the number of bytes that can be read/written to that stream, executing an action when the budget is exceeded.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.#ctor(System.IO.Stream,System.Int64,System.Action{System.Int64})">
            <summary>
            Creates an instance of GovernedStream
            </summary>
            <param name="stream">The stream to govern</param>
            <param name="byteBudget">The number of bytes that can be read/written to the stream.</param>
            <param name="budgetExceededAction">An action that is executed when the budget is exceeded. If the action doesn't throw an exception, the read/write operations will complete normally. The parameter to the action is the value of byteBudget.</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.Flush">
            <summary>
            Clears all buffers for the inner stream and causes any buffered data to be written to the underlying device.
            </summary>
            <exception cref="T:System.IO.IOException">An I/O error occurs. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the inner stream. Changing the position doesn't count against the budget for the stream.
            </summary>
            <returns>
            The new position within the inner stream.
            </returns>
            <param name="offset">A byte offset relative to the <paramref name="origin"/> parameter. </param><param name="origin">A value of type <see cref="T:System.IO.SeekOrigin"/> indicating the reference point used to obtain the new position. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the inner stream. Changing the length doesn't count against the budget for the stream.
            </summary>
            <param name="value">The desired length of the current stream in bytes. </param><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support both writing and seeking, such as if the stream is constructed from a pipe or console output. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read. If the bytes read cause the count to exceed the budget, the budget exceeded action will be executed. 
            </summary>
            <remarks>
            More bytes than specified in the budget may be read into the buffer, and the budget exceeded action will occur after the read has happened.
            </remarks>
            <returns>
            The total number of bytes read into the buffer. This can be less than the number of bytes requested if that many bytes are not currently available, or zero (0) if the end of the stream has been reached.
            </returns>
            <param name="buffer">An array of bytes. When this method returns, the buffer contains the specified byte array with the values between <paramref name="offset"/> and (<paramref name="offset"/> + <paramref name="count"/> - 1) replaced by the bytes read from the current source. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin storing the data read from the current stream. </param><param name="count">The maximum number of bytes to be read from the current stream. </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is larger than the buffer length. </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support reading. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            When overridden in a derived class, writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written. If the bytes to write would exceed the budget, then the budget exceeded action is executed.
            </summary>
            <param name="buffer">An array of bytes. This method copies <paramref name="count"/> bytes from <paramref name="buffer"/> to the current stream. </param><param name="offset">The zero-based byte offset in <paramref name="buffer"/> at which to begin copying bytes to the current stream. </param><param name="count">The number of bytes to be written to the current stream. </param><exception cref="T:System.ArgumentException">The sum of <paramref name="offset"/> and <paramref name="count"/> is greater than the buffer length. </exception><exception cref="T:System.ArgumentNullException"><paramref name="buffer"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> or <paramref name="count"/> is negative. </exception><exception cref="T:System.IO.IOException">An I/O error occurs. </exception><exception cref="T:System.NotSupportedException">The stream does not support writing. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><filterpriority>1</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous read operation.
            </summary>
            <returns>
            An <see cref="T:System.IAsyncResult"/> that represents the asynchronous read, which could still be pending.
            </returns>
            <param name="buffer">The buffer to read the data into. </param><param name="offset">The byte offset in <paramref name="buffer"/> at which to begin writing data read from the stream. </param><param name="count">The maximum number of bytes to read. </param><param name="callback">An optional asynchronous callback, to be called when the read is complete. </param><param name="state">A user-provided object that distinguishes this particular asynchronous read request from other requests. </param><exception cref="T:System.IO.IOException">Attempted an asynchronous read past the end of the stream, or a disk error occurs. </exception><exception cref="T:System.ArgumentException">One or more of the arguments is invalid. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><exception cref="T:System.NotSupportedException">The current Stream implementation does not support the read operation. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.EndRead(System.IAsyncResult)">
            <summary>
            Waits for the pending asynchronous read to complete.
            </summary>
            <returns>
            The number of bytes read from the stream, between zero (0) and the number of bytes you requested. Streams return zero (0) only at the end of the stream, otherwise, they should block until at least one byte is available.
            </returns>
            <param name="asyncResult">The reference to the pending asynchronous request to finish. </param><exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is null. </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult"/> did not originate from a <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"/> method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Begins an asynchronous write operation.
            </summary>
            <returns>
            An IAsyncResult that represents the asynchronous write, which could still be pending.
            </returns>
            <param name="buffer">The buffer to write data from. </param><param name="offset">The byte offset in <paramref name="buffer"/> from which to begin writing. </param><param name="count">The maximum number of bytes to write. </param><param name="callback">An optional asynchronous callback, to be called when the write is complete. </param><param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests. </param><exception cref="T:System.IO.IOException">Attempted an asynchronous write past the end of the stream, or a disk error occurs. </exception><exception cref="T:System.ArgumentException">One or more of the arguments is invalid. </exception><exception cref="T:System.ObjectDisposedException">Methods were called after the stream was closed. </exception><exception cref="T:System.NotSupportedException">The current Stream implementation does not support the write operation. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.EndWrite(System.IAsyncResult)">
            <summary>
            Ends an asynchronous write operation.
            </summary>
            <param name="asyncResult">A reference to the outstanding asynchronous I/O request. </param><exception cref="T:System.ArgumentNullException"><paramref name="asyncResult"/> is null. </exception><exception cref="T:System.ArgumentException"><paramref name="asyncResult"/> did not originate from a <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)"/> method on the current stream. </exception><exception cref="T:System.IO.IOException">The stream is closed or an internal error has occurred.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.Close">
            <summary>
            Closes the current stream and the inner stream associated with the current stream.
            </summary>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:System.IO.Stream"/> and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.AddToBudget(System.Int32)">
            <summary>
            Adds to the budget and executes the budgetExceededAction if the budget is exceeded.
            </summary>
            <param name="bytesRead"></param>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.CanTimeout">
            <summary>
            Gets a value that determines whether the current stream can time out.
            </summary>
            <returns>
            A value that determines whether the current stream can time out.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.ReadTimeout">
            <summary>
            Gets or sets a value, in miliseconds, that determines how long the stream will attempt to read before timing out. 
            </summary>
            <returns>
            A value, in miliseconds, that determines how long the stream will attempt to read before timing out.
            </returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IO.Stream.ReadTimeout"/> method always throws an <see cref="T:System.InvalidOperationException"/>. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.GovernedStream.WriteTimeout">
            <summary>
            Gets or sets a value, in miliseconds, that determines how long the stream will attempt to write before timing out. 
            </summary>
            <returns>
            A value, in miliseconds, that determines how long the stream will attempt to write before timing out.
            </returns>
            <exception cref="T:System.InvalidOperationException">The <see cref="P:System.IO.Stream.WriteTimeout"/> method always throws an <see cref="T:System.InvalidOperationException"/>. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.IHealthCheckAgent.GetInformation">
            <summary>
            Generates a collection of informational messages that don't correspond to a health check. This is generally used for state information about the
            service or server, such as environmental and configuration information. 
            </summary>
            <returns>Collection of HealthInformation. If the health check agent doesn't provide additional information, an empty IEnumerable should be returned.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.IHealthCheckAgent.ExecuteHealthChecks">
            <summary>
            Generates a collection of results for the health checks performed by this agent. HealthResult are targeted for operations that can fail or succeed.
            </summary>
            <returns>Collection of HealthResult. If this agent doesn't perform health checks (e.g. just provides informational notes), an empty IEnumerable should be returned.</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.IHealthCheckAgent.Category">
            <summary>
            Gets the category that the current health check belongs to
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.IHealthCheckAgent.Level">
            <summary>
            Gets a number that indicates the level that this health check belongs to.
            </summary>
            <remarks>
            This value is used to filter the health checks that are performed. Typically the level corresponds to the expense of health check.
            
            General guidance for the levels are:
              0 - Indicates that the health check should be just a ping. Very few health checks should be at level 0.
              1 - Indicates a minimal check. Should be limited to quick checks that don't require network or disk I/O.
              2 - Indicates a basic check of major subsystems. This includes connectivity to remote services, remote data stores, critical disk files, etc
              3+ - This indicates a deeper and more expensive test that should not be run too frequently. The sky's the limit for levels above 2.
            </remarks>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.HealthCheckAgentBase.GetInformation">
            <summary>
            Generates a collection of informational messages that don't correspond to a health check. This is generally used for state information about the
            service or server, such as environmental and configuration information. 
            </summary>
            <returns>Collection of HealthInformation. If the health check agent doesn't provide additional information, an empty IEnumerable should be returned.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.HealthCheckAgentBase.ExecuteHealthChecks">
            <summary>
            Generates a collection of results for the health checks performed by this agent. HealthResult are targeted for operations that can fail or succeed.
            </summary>
            <returns>Collection of HealthResult. If this agent doesn't perform health checks (e.g. just provides informational notes), an empty IEnumerable should be returned.</returns>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.HealthCheckAgentBase.Category">
            <summary>
            Gets the category that the current health check belongs to
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.HealthCheckAgentBase.Level">
            <summary>
            Gets a number that indicates the level that this health check belongs to.
            </summary>
            <remarks>
            This value is used to filter the health checks that are performed. Typically the level corresponds to the expense of health check.
            
            General guidance for the levels are:
              0 - Indicates that the health check should be just a ping. Very few health checks should be at level 0.
              1 - Indicates a minimal check. Should be limited to quick checks that don't require network or disk I/O.
              2 - Indicates a basic check of major subsystems. This includes connectivity to remote services, remote data stores, critical disk files, etc
              3+ - This indicates a deeper and more expensive test that should not be run too frequently. The sky's the limit for levels above 2.
            </remarks>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.HealthCheckRunner.Execute(System.Int32)">
            <summary>
            Executes the agents for this health check and returns the results.
            </summary>
            <param name="level">The max level of the agents to execute.</param>
            <returns>The generated HealthCheckResponse</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.HealthCheck.MultiValuedInfoHealthAgent.GetInformation">
            <summary>
            Generates a collection of informational messages that don't correspond to a health check. This is generally used for state information about the
            service or server, such as environmental and configuration information. 
            </summary>
            <returns>Collection of HealthInformation. If the health check agent doesn't provide additional information, an empty IEnumerable should be returned.</returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.CacheControlPolicy">
            <summary>
            Defines common HTTP cache-control policies
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Utils.Http.CacheControlPolicy.NeverCache">
            <summary>
            Do not allow caching of the response
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Utils.Http.CacheControlPolicy.NeverExpire">
            <summary>
            Cache the response for the maximium time allowed by RFC 2616 (1 year),
            and with public visibility.
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Utils.Http.CacheControlPolicy.StatusCodesToSetCacheHeader">
            <summary>
            From RFC 2616: "A response received with a status code of 200, 203, 206, 300, 301 or
            410 MAY be stored by a cache and used in reply to a subsequent
            request, subject to the expiration mechanism, unless a cache-control
            directive prohibits caching". Only for codes in this list will we
            set the no-cache cache header.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageExtensions">
            <summary>
            Set of extensions to help grains act on HttpRequestMessages from client API requests
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageTransportExtensions">
            <summary>
            Set of extensions to facilitate packing and unpacking HttpRequestMessages into a transport structure.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageTransportExtensions.ToRequestMessage(Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageTransport)">
            <summary>
            Converts an HttpRequestMessageTransport into an HttpRequestMessage.
            </summary>
            <param name="messageTransport">The HttpRequestMessageTransport to convert.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageTransportExtensions.GetContentValue``1(System.Net.Http.HttpRequestMessage,System.Collections.Generic.IEnumerable{System.Net.Http.Formatting.MediaTypeFormatter})">
            <summary>
            Deserializes the content in the specified HttpRequestMessage into a strongly typed .Net object using the specified formatters.
            </summary>
            <typeparam name="T">The type to convert the Content body into.</typeparam>
            <param name="message">The HttpRequestMessage to get the content from.</param>
            <param name="formatters">List of MediaTypeFormatters to use when deserializing the content. Pass null to use the default formatters (supports XML and JSON deserialization).</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageTransportExtensions.ToTransportMessageAsync(System.Net.Http.HttpRequestMessage,Microsoft.Studios.StudiosNebula.Utils.Http.RequestIdentityAssertions)">
            <summary>
            Asynchronously create a HttpRequestMessageTransport object based on an existing HttpRequestMessage object. 
            </summary>
            <param name="message">The message to convert.</param>
            <param name="userIdentity">A RequestIdentityAssertion object to include in the transport object. Pass null to create a default, unauthenticated assertion.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageTransportExtensions.ToTransportMessageAsync(System.Net.HttpListenerRequest,Microsoft.Studios.StudiosNebula.Utils.Http.RequestIdentityAssertions)">
            <summary>
            Asynchronously create a HttpRequestMessageTransport object based on an existing HttpListenerRequest object. 
            </summary>
            <param name="request">The message to convert.</param>
            <param name="userIdentity">A RequestIdentityAssertion object to include in the transport object. Pass null to create a default, unauthenticated assertion.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.HttpListenerContextExtensions">
            <summary>
            Extension methods for HttpListenerContext
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Utils.Http.HttpListenerContextExtensions.httpContentHeaders">
            <summary>
            Array of all the headers within HttpContent
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpListenerContextExtensions.GetMultiPartFiles(System.Net.HttpListenerRequest)">
            <summary>
            Gets the multi-part content within the HttpListenerRequest
            </summary>
            <param name="listenerRequest">
            The listener request.
            </param>
            <returns>
            An array of byte arrays containing the multi-part content 
            </returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpListenerContextExtensions.GetFirstMultiPartFileAndContentType(System.Net.HttpListenerRequest)">
            <summary>
            Gets the first file and its content type from a multi-part collection. 
            </summary>
            <param name="listenerRequest">The Http request listener object.</param>
            <returns>A tuple of the file as a byte array and its content type as a string.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpListenerContextExtensions.CreateRequestMessage(System.Net.HttpListenerRequest)">
            <summary>
            Creates the HttpRequestMessage from HttpListenerRequest object
            </summary>
            <param name="listenerRequest">
            The listener request.
            </param>
            <returns>
            <see cref="T:System.Net.Http.HttpRequestMessage"/> HttpRequestMessage object
            </returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.HttpRequestMessageTransport">
            <summary>
            A data transfer object to allow passing a HttpRequestMessage across machine boundries. It is intended to be used primarily for transport purposes
            and it's expected that the real HttpRequestMessage will be used for actual programatic interaction instead of this DTO.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransport">
            <summary>
            A data transfer object to allow passing a HttpResponseMessage across machine boundries. It is intended to be used primarily for transport purposes
            and it's expected that the real HttpRequestMessage will be used for actual programatic interaction instead of this DTO.
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions">
            <summary>
            Fluent helpers for common response message creation patterns
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithStatus(System.Net.Http.HttpResponseMessage,System.Net.HttpStatusCode,System.String)">
            <summary>
            Sets the status code for the response and optionally the reason phrase
            </summary>
            <param name="response">The response message instance to set the status on.</param>
            <param name="status">The status code to return with the response.</param>
            <param name="reasonPhrase">The reason phrase to send along with the status code. Pass null to use the standard phrase that matches the status.</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithContent(System.Net.Http.HttpResponseMessage,System.String)">
            <summary>
            Sets the content of the response to the specified string
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="content">A string to send in the content (body) of the response</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithContent(System.Net.Http.HttpResponseMessage,System.Byte[])">
            <summary>
            Sets the content of the response to the specified byte array
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="content">A byte array to send in the content (body) of the response</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithContent(System.Net.Http.HttpResponseMessage,System.Net.Http.HttpContent)">
            <summary>
            Sets the content of the response to the specified HttpContent instance.
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="content">A HttpContent to send in the content (body) of the response</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithContent``1(System.Net.Http.HttpResponseMessage,``0,System.Collections.Generic.IEnumerable{System.Net.Http.Formatting.MediaTypeFormatter},System.Net.Http.Formatting.IContentNegotiator)">
            <summary>
            Sets the content of the response to a representation of a CLR object.
            </summary>
            <typeparam name="T">The type of the object to generate the content from</typeparam>
            <param name="response">The response message instance to modify.</param>
            <param name="content">A populated object that can be converted by a MediaTypeFormatter into a serialized message body.</param>
            <param name="formatters">List of MediaTypeFormatters which are possible formatters to use. Passing null will use the default Nebula list, which supports XML and JSON.</param>
            <param name="contentNegotiator">An IContentNegotiator which is used to select the MediaTypeFormatter to use. Passing null will use the default WebAPI content negotiator.</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithContent(System.Net.Http.HttpResponseMessage,System.Type,System.Object,System.Collections.Generic.IEnumerable{System.Net.Http.Formatting.MediaTypeFormatter},System.Net.Http.Formatting.IContentNegotiator)">
            <summary>
            Sets the content of the response to a representation of a CLR object.
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="serializationType">The type to use during serialization.</param>
            <param name="content">A populated object that can be converted by a MediaTypeFormatter into a serialized message body.</param>
            <param name="formatters">List of MediaTypeFormatters which are possible formatters to use. Passing null will use the default Nebula list, which supports XML and JSON.</param>
            <param name="contentNegotiator">An IContentNegotiator which is used to select the MediaTypeFormatter to use. Passing null will use the default WebAPI content negotiator.</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithCache(System.Net.Http.HttpResponseMessage,System.Net.Http.Headers.CacheControlHeaderValue)">
            <summary>
            Sets the Cache-Control information for the response
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="cacheControl">The cache control information to add to the response.</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithContentType(System.Net.Http.HttpResponseMessage,System.String)">
            <summary>
            Sets the Content-Type information for the content in the response. The message must have some content defined before defining a content type.
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="contentType">The string that specifies the content type.</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithETag(System.Net.Http.HttpResponseMessage,System.String,System.Boolean)">
            <summary>
            Sets the ETag information for the response
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="etag">The arbitrary string to send in the ETag header.</param>
            <param name="isWeak">Flag indicating whether this is a weak ETag.</param>
            <returns>The modified response message instance.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageExtensions.WithException(System.Net.Http.HttpResponseMessage,System.Exception)">
            <summary>
            Adds details about an exception to a custom header in the response.
            </summary>
            <param name="response">The response message instance to modify.</param>
            <param name="exceptionToAttach">The exception to provide the details for. Passing null will clear any existing exception details header.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransportExtensions">
            <summary>
            Set of extensions to facilitate packing and unpacking HttpResponseMessages into a transport structure.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransportExtensions.ToResponseMessage(Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransport)">
            <summary>
            Converts an HttpResponseMessageTransport into an HttpResponseMessage.
            </summary>
            <param name="messageTransport">The HttpResponseMessageTransport to convert.</param>
            <returns>A HttpResponseMessage populated with the data from the message transport structure.</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransportExtensions.SendToListenerResponseAsync(Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransport,System.Net.HttpListenerResponse)">
            <summary>
            Sends the specified HttpResponseMessageTransport to a HttpListenerResponse.
            </summary>
            <param name="messageTransport">The HttpResponseMessageTransport to send.</param>
            <param name="response">The response to send using the transport</param>
            <returns>A Task tracking this async execution</returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransportExtensions.GetContentValue``1(System.Net.Http.HttpResponseMessage,System.Collections.Generic.IEnumerable{System.Net.Http.Formatting.MediaTypeFormatter})">
            <summary>
            Deserializes the content in the specified HttpResponseMessage into a strongly typed .Net object using the specified formatters.
            </summary>
            <typeparam name="T">The type to convert the Content body into.</typeparam>
            <param name="message">The HttpResponseMessage to get the content from.</param>
            <param name="formatters">List of MediaTypeFormatters to use when deserializing the content. Pass null to use the default formatters (supports XML and JSON deserialization).</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Http.HttpResponseMessageTransportExtensions.ToTransportMessageAsync(System.Net.Http.HttpResponseMessage,System.Boolean)">
            <summary>
            Asynchronously create a HttpResponseMessageTransport object based on an existing HttpResponseMessage object. 
            </summary>
            <param name="message">The message to convert.</param>
            <param name="disposeMessage">If true, dispose the message object after creating the transport message.</param>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.NebulaMediaTypeFormatters">
            <summary>
            Defines some standard media type formatter configurations and sets of media type formatters
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.Http.NebulaMediaTypeFormatters.DefaultXmlMediaTypeFormatter">
            <summary>
            Gets the Nebula default configuration of an XmlMediaTypeFormatter
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.Http.NebulaMediaTypeFormatters.DefaultJsonMediaTypeFormatter">
            <summary>
            Gets the Nebula default configuration of a JsonMediaTypeFormatter
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.Http.NebulaMediaTypeFormatters.XmlAndJsonWithXmlDefault">
            <summary>
            Gets a collection of formatters that handle both Xml and Json media types, with XML as the default if no Accept/Content-Type headers are defined
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.Http.NebulaMediaTypeFormatters.XmlAndJsonWithJsonDefault">
            <summary>
            Gets a collection of formatters that handle both Xml and Json media types, with JSON as the default if no Accept/Content-Type headers are defined
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.Http.NebulaMediaTypeFormatters.DefaultFormatters">
            <summary>
            Gets or sets the set of media type formatters that Nebula will use by default if no formatters are specified
            </summary>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Http.ExposedByteArrayContent">
            <summary>
            A specialized ByteArrayContent variant that allows direct access to the byte array stored by the ByteArrayContent. 
            This class allows for an optimization of creating an HttpResponseMessageTransport without making an entire copy of the byte[] data,
            but does so by breaking encapsulation. Use with caution.
            </summary>
        </member>
        <member name="P:Microsoft.Studios.StudiosNebula.Utils.Http.ExposedByteArrayContent.RawByteArray">
            <summary>
            Gets the byte array specified in the constructor.
            </summary>
            <remarks>
            The contents of the array should not be modified.
            </remarks>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Retry">
            <summary>
            Provides methods to retry an operation a number of times.
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Retry.RetryAction(System.UInt32,System.Action,System.Action{System.Exception})">
            <summary>
            Tries an action a certain number of times until it doesn't throw an exception.
            </summary>
            <exception cref="T:System.Exception">The exception thrown on the last invocation of the action if it did not succeed.</exception>
            <param name="maxTries">The maximum number of times to try the action.</param>
            <param name="action">The action to try.</param>
            <param name="exceptionHandler">A function to execute when an exception occurs. Usually used for logging.</param>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent">
            <summary>
            Represents HttpContent of Json type
            </summary>
        </member>
        <member name="F:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent.info">
            <summary>
            JsonSerializable information
            </summary>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent.#ctor(Microsoft.Studios.StudiosNebula.Utils.Serialization.IJsonSerializable)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent"/> class.
            </summary>
            <param name="info">
            JsonSerializable information
            </param>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent.ReadJson``1(System.Net.Http.HttpContent)">
            <summary>
            Get the Json value from HttpContent
            </summary>
            <param name="content">
            HttpContent parameter.
            </param>
            <typeparam name="T">
            IJsonSerializable httpcontent
            </typeparam>
            <returns>
            JsonValue equivalent of the HttpContent
            </returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent.SerializeToStreamAsync(System.IO.Stream,System.Net.TransportContext)">
            <summary>
            Asynchronously serializes JsonHttpContent into the underlying stream.
            </summary>
            <param name="stream">
            Stream parameter
            </param>
            <param name="context">
            TransportContext parameter
            </param>
            <returns>
            A Task object to serialize the JsonHttpContent object
            </returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent.TryComputeLength(System.Int64@)">
            <summary>
            Try and compute length
            </summary>
            <param name="length">
            Always 0
            </param>
            <returns>
            False always
            </returns>
        </member>
        <member name="M:Microsoft.Studios.StudiosNebula.Utils.Serialization.JsonHttpContent.SerializeToStream(System.IO.Stream,System.Net.TransportContext)">
            <summary>
            Serializes into the underlysing stream
            </summary>
            <param name="stream">
            Stream parameter
            </param>
            <param name="context">
            TransportContext parameter
            </param>
        </member>
        <member name="T:Microsoft.Studios.StudiosNebula.Utils.SystemWideSingleInstance`1">
            <summary>
            Represents an object which can only be created a single time on the OS.
            
            Uses an OS mutex to ensure that only a single instance of the object is created.
            
            Usually this is due to an object using system resources that must be uniquely held.
            </summary>
        </member>
    </members>
</doc>
