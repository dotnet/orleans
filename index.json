{
  "Tutorials/index.html": {
    "href": "Tutorials/index.html",
    "title": "Step by Step Tutorials | Microsoft Orleans Website",
    "keywords": "These tutorials are for the 2.0 release Orleans 2.0 is a significant overhaul from the 1.x versions. For 1.5 Documentation and Tutorials , refer to the respective sections that are snapshots of the documentation as of the 2.0 release."
  },
  "Tutorials/Declarative-Persistence.html": {
    "href": "Tutorials/Declarative-Persistence.html",
    "title": "Declarative Persistence | Microsoft Orleans Website",
    "keywords": "Declarative Persistence In the second tutorial, we saw how grain state survived the client being shut down, which opens up for a lot of cache-like scenarios, where Orleans is relied upon as a kind of 'cache with behavior,' an object-oriented cache, if you will. That is already very valuable and goes a long way toward achieving server-side scalability with a simple, familiar, programming model and the built-in single-threaded execution guarantees. However, it is sometimes the case that some of the state you are accumulating belongs in some form of permanent storage, so that it can survive a silo shutdown, or a grain migrating from one silo to another for load-balancing or a complete restart/shutdown of the service. What we have seen so far will not support such situations. Fortunately, Orleans offers a simple declarative model for identifying the state that needs to be stored in a permanent location, while leaving the decision when to save and restore state under programmatic control. You are not required to use the declarative persistence mechanism and can still access storage directly from your grain code, but it’s a nice way to save you some boilerplate code and build applications that are portable across various storage services. Getting Started We'll continue to build on our employee-and-manager sample. The first thing we need to do is make the identities of our workers and managers a little more predictable. In the sample, they were assigned GUIDs using Guid.NewGuid() , which is convenient, but doesn't let us find them in a subsequent run. Therefore, we'll create a set of GUIDs first, then use them as the worker identities. The modified client program looks like this: private static async Task DoClientWork(IClusterClient client) { ... var ids = new string[] { \"42783519-d64e-44c9-9c29-399e3afaa625\", \"d694a4e0-1bc3-4c3f-a1ad-ba95103622bc\", \"9a72b0c6-33df-49db-ac05-14316edd332d\", \"6526a751-b9ac-4881-9bfb-836ecce2ca9f\", \"ae4b106f-3c96-464a-b48d-3583ed584b17\", \"b715c40f-d8d2-424d-9618-76afbc0a2a0a\", \"5ad92744-a0b1-487b-a9e7-e6b91e9a9826\", \"e23a55af-217c-4d76-8221-c2b447bf04c8\", \"2eef0ac5-540f-4421-b9a9-79d89400f7ab\" }; var e0 = client.GetGrain<IEmployee>(Guid.Parse(ids[0])); var e1 = client.GetGrain<IEmployee>(Guid.Parse(ids[1])); var e2 = client.GetGrain<IEmployee>(Guid.Parse(ids[2])); var e3 = client.GetGrain<IEmployee>(Guid.Parse(ids[3])); var e4 = client.GetGrain<IEmployee>(Guid.Parse(ids[4])); var m0 = client.GetGrain<IManager>(Guid.Parse(ids[5])); var m1 = client.GetGrain<IManager>(Guid.Parse(ids[6])); ... } Note: If you are transitioning from Orleans 1.5, you will notice that the Client is no longer static. Please refer to Migration from Orleans 1.5 to 2.0 page. Next, we'll do some silo configuration, in order to configure the storage provider that will give us access to persistent storage. The SiloHost project includes a file Program.cs which is where we find the following section: var builder = new SiloHostBuilder() .UseLocalhostClustering() .Configure<EndpointOptions>(options => options.AdvertisedIPAddress = IPAddress.Loopback) .ConfigureLogging(logging => logging.AddConsole()); var host = builder.Build(); await host.StartAsync(); return host; If this is hosted in Azure Cloud Services, then one can use either of the following before calling builder.Build() to use Azure to persist grain state: // Stores grains as composition of fields builder.AddAzureTableGrainStorage(option => option.ConnectionString = your_connection_string); // Stores grains as blobs builder.AddAzureBlobGrainStorage(option => option.ConnectionString = your_connection_string); The MemoryStorage provider is fairly uninteresting, since it doesn't actually provide any permanent storage; it's intended for debugging persistent grains while having no access to a persistent store. In our case, that makes it hard to demonstrate persistence, so we will rely on a real storage provider. Depending on whether you have already set up (and want to use) an Azure storage account, or would like to rely on the Azure storage emulator, you should add one of the other two lines, but not both. You can use either the AddAzureTableStorageProvider() function or the AddAzureBlobStorageProvider() function depending on how you want to store information. In the case of the former, you have to start the Azure storage emulator after installing the latest version of the Azure SDK. In the case of the latter, you will have to create a Azure storage account and enter the name and keys in the configuration file. With one of those enabled, we're ready to tackle the grain code. Note: With Orleans 2.0, a lot of functionality have been split off into smaller packages to allow more granular configuration and deployment. This includes the Azure storage provider. Please install Orleans.Persistence.AzureStorage package if you would like to use Azure as a storage provider. You could find some of the other storage providers maintained by the Orleans community by searching for Orleans.Persistence . Declaring State Identifying that a grain should use persistent state takes three steps: declaring a class for the state, changing the grain base class, and identifying the storage provider. The first step, declaring a state class in the grain implementations project, simply means identifying the information of an actor that should be persisted and creating what looks like a record of the persistent data -- each state component is represented by a property with a getter and a setter. For employees, we want to persist all the state: public class EmployeeState { public int Level { get; set; } public IManager Manager { get; set; } } and for managers, we must store the direct reports, but the _me reference may continue to be created during activation. public class ManagerState { public List<IEmployee> Reports { get; set; } } Then, we change the grain class declaration to identify the state interface (e.g., from Orleans.Grain to Orleans.Grain<EmployeeState> ) and remove the variables that we want persisted. Make sure to remove level , and manager from the Employee class and _reports from the Manager class. In addition, we must update the other functions to reflect these removals. We also add an attribute to identify the storage provider: [StorageProvider(ProviderName = \"AzureStore\")] public class Employee : Orleans.Grain<EmployeeState>, Interfaces.IEmployee and [StorageProvider(ProviderName=\"AzureStore\")] public class Manager : Orleans.Grain<ManagerState>, IManager At risk of stating the obvious, the name of the storage provider attribute should match the name as it was used in configuring the Silo. This indirection is what allows you to delay choices around where to store grain state until deployment. Given these declarative changes, the grain should no longer rely on a private fields to keep compensation level and manager. Instead, the grain base class gives us access to the state via a State property that is available to the grain. For example: public Task SetManager(IManager manager) { State.Manager = manager; return TaskDone.Done; } Controlling Checkpoints The question that remains is when the persistent state gets saved to the storage provider. One choice that the Orleans designers could have made would be to have the runtime save state after every method invocation, but that turns out to be undesirable because it is far too conservative -- not all invocations will actually modify the state on all invocations, and some will never modify it. Rather than employing a complex system to evaluate state differentials after each method, Orleans asks the grain developer to add the necessary logic to determine whether state needs to be saved or not. Saving the state using the storage provider is easily accomplished by calling base.WriteStateAsync() . Thus, the final version of the Promote() and SetManager() methods looks like this: public Task Promote(int newLevel) { State.Level = newLevel; return base.WriteStateAsync(); } public Task SetManager(IManager manager) { State.Manager = manager; return base.WriteStateAsync(); } In the Manager class, there's only one method that need to be modified to write out data, AddDirectReport() . It should look like this: public async Task AddDirectReport(IEmployee employee) { if (State.Reports == null) { State.Reports = new List<IEmployee>(); } State.Reports.Add(employee); await employee.SetManager(this); var data = new GreetingData { From = this.GetPrimaryKey(), Message = \"Welcome to my team!\" }; await employee.Greeting(data); Console.WriteLine(\"{0} said: {1}\", data.From.ToString(), data.Message); await base.WriteStateAsync(); } Let's try this out! Set a breakpoint in Employee.Promote() . When we run the client code the first time and hit the breakpoint, the level field should be 0 and the newLevel parameter either 10 or 11 : ![](../Images/Persistence 2.PNG) Let the application finish (reach the 'Hit Enter...' prompt) and exit. Run it again, and compare what happens when you look at state this second time around: ![](../Images/Persistence 3.PNG) Just Making Sure... It's worth checking what Azure thinks about the data. Using a storage explorer such as Azure Storage Explorer (ASE) or the one built in to Server Explorer in Visual Studio 2013, open the storage account (or developer storage of the emulator) and find the 'OrleansGrainState' table. It should look something like this (you have to hit 'Query' in ASE): ![](../Images/Persistence 4.PNG) If everything is working correctly, the grain keys should appear in the PartitionKey column, and the qualified class name of the grains should appear in the RowKey column. Mixing Things A grain may contain a combination of persisted and transient state. Any transient state should be represented by private fields in the grain class. A common use for mixing the two is to cache some computed version of the persisted state in private fields while it is present in memory. For example, a stack of elements may be externally represented as a List<T> , but internally, as a Stack<T> . In the case of our Manager class, the _me field is simply a cached value, something we don't even need to keep as a field in the first place, it can be created any time we need it, but since it's going to be a commonly used value, it's worth keeping it around in a transient field. Automatic loading of state If a grain type has state, at activation time the state will be loaded from storage and then OnActivateAsync is called so you can be sure that the state is loaded when initializing your grain. This is the only case that Orleans calls ReadStateAsync automatically. If you want to write the state or read it in some other place, you should do it on your own. Normally you should not need to call ReadStateAsync yourself unless you are doing something specific regarding handling corrupted state or something else. Handling failures using persistence Generally speaking reading and writing a grain's state is a good mechanism to handle failures as well as serving its original intent. There is a possibility that your grain call fails in the middle of a method due to different reasons and you end up with a state which is half changed. In this case reading from storage can return your state to the last correct state. Alternatively, having gotten into such a state, the grain can request to get immediately deactivated by calling DeactivateOnIdle(), so that its a next request to it would trigger reactivation of the grain, which would reread the persistent state and reconstruct its in-memory copy. Deactivation is the cleanest way of resetting a grain to its last know good state, but if you want to avoid the cost of the reactivation process, you can reset its state and rerun any initialization logic (for example, by calling OnActivateAsync ) instead of deactivating the grain. Next Next, we'll see how we can call our grains from an MVC web application. Handling Failure"
  },
  "Community/Contributing.html": {
    "href": "Community/Contributing.html",
    "title": "Contributing to Orleans | Microsoft Orleans Website",
    "keywords": "Contributing to Orleans Some notes and guidelines for developers wanting to contribute to Orleans. Contributing To This Project Here are some pointers for anyone looking for mini-features and work items that would make a positive contribution to Orleans. These are just a few ideas, so if you think of something else that would be useful, then spin up a discussion thread on GitHub to discuss the proposal, and go for it! Orleans GitHub Repository Pull requests are always welcome! Ideas for Contributions Intern and Student Projects Some suggestions for possible intern / student projects. Documentation Guidelines A style guide for writing documentation for this site. Code Contributions: This project uses the same contribution process as the other DotNet projects on GitHub. DotNet Project Contribution Guidelines Guidelines and workflow for contributing to DotNet projects on GitHub. DotNet CLA Contribution License Agreement for DotNet projects on GitHub. .NET Framework Design Guidelines Some basic API design rules, coding standards, and style guide for .NET Framework APIs. Coding Standards and Conventions We try not to be too OCD about coding style wars, but in case of disputes we do fall back to the core principles in the two \".NET Coding Standards\" books used by the other DotNet OSS projects on GitHub: C# Coding Style Guide .NET Framework Design Guidelines There are lots of other useful documents on the .NET CoreCLR and .NET Core Framework documentation sites which are worth reading, although most experienced C# developers will probably have picked up many of those best-practices by osmosis, particularly around performance and memory management. Source Code Organization Orleans has not religiously followed a \"One Class Per File\" rule, but instead we have tried to use pragmatic judgment to maximize the change of \"code understand-ability\" for developers on the team. If lots of small-ish classes share a \"common theme\" and/or are always dealt with together, then it is OK to place those into one source code file in most cases. See for example the various \"log consumer\" classes were originally placed in single source file, as they represented a single unit of code comprehension. As a corollary, it is much easier to find the source code for a class if it is in a file with the same name as the class [similar to Java file naming rules], so there is a tension and value judgment here between code find-ability and minimizing / constraining the number of projects in a solution and files within a project [which both have direct impact on the Visual Studio \"Opening\" and \"Building\" times for large projects]. Code search tools in VS and ReSharper definitely help here. Dependencies and Inter-Project References One topic that we are very strict about is around dependency references between components and sub-systems. Component / Project References References between projects in a solution must always use \" Project References \" rather than \" DLL References \" to ensure that component build relationships are known to the build tools. Right : <ProjectReference Include=\"..\\Orleans\\Orleans.csproj\"> <Project>{BC1BD60C-E7D8-4452-A21C-290AEC8E2E74}</Project> <Name>Orleans</Name> </ProjectReference> Wrong : <Reference Include=\"Orleans\" > <HintPath>..\\Orleans\\bin\\Debug\\Orleans.dll</HintPath> </Reference> In order to help ensure we keep inter-project references clean, then on the build servers [and local Build.cmd script] we deliberately use side-by-side input .\\src and output .\\Binaries directories rather than the more normal in-place build directory structure (eg. [PROJ]\\bin\\Release ) used by VS on local dev machines. Unified Component Versions We use the same unified versions of external component throughout the Orleans code base, and so should never need to add bindingRedirect entries in App.config files. Also, in general it should almost never be necessary to have Private=True elements in Orleans project files, except to override a conflict with a Windows / VS \"system\" component. Some package management tools can occasionally get confused when making version changes, and sometimes think that we are using multiple versions of the same assembly within a solution, which of course we never do. We long for the day when package management tools for .NET can make version changes transactionally! Until then, it is occasionally necessary to \"fix\" the misguided actions of some .NET package management tools by hand-editing the .csproj files (they are just XML text files) back to sanity and/or using the \"Discard Edited Line\" functions that most good Git tools such as Atlassian SourceTree provide. Using \"sort\" references and unified component versions avoids creating brittle links between Orleans run-time and/or external components, and has proved highly effective in the last several years at reducing stress levels for the Orleans Team during important deployment milestones. :)"
  },
  "Community/Ideas-for-Contributions.html": {
    "href": "Community/Ideas-for-Contributions.html",
    "title": "Ideas for Contributions | Microsoft Orleans Website",
    "keywords": "Ideas for Contributions These are some of the ideas for contributing to Orleans. Just an initial list for consideration, meant to be a live document. If you are interested in any of these or one that is not listed, create an issue to discuss it. We roughly put them into 3 size categories based on our gut feel, which may be wrong: Small - hours of work Medium - couple of days of work Large - big projects, multiple days up to weeks of work Project template/wizard for Azure deployment [Medium/Large] Worker role for silos (in our experience it is better to star a silo as a standalone process and wait on the process handle in the worker roles code) Worker/web role for frontend clients Configuration of diagnostics, ETW tracing, etc. Try Azure SDK plug-in as suggested here by @richorama. Cluster monitoring dashboard [Medium] https://github.com/OrleansContrib/OrleansMonitor may be a good start Proper support for F# [Medium/Large] See Issue #38 Orleans backplane for SignalR [Medium] See Issue #73 Port Orleans to coreclr [Medium] See Issue #368 Some APIs from the full .NET got deprecated in coreclr, mainly around files and reflection, but at large the porting effort shouldn't be too big. This will allow to run Orleans efficiently cross platform. Secure communication between silos and clients Add support for secure communication mode with certificates used for encryption of messages."
  },
  "Community/Links.html": {
    "href": "Community/Links.html",
    "title": "Links | Microsoft Orleans Website",
    "keywords": "Links By Orleans team Orleans Architecture: Principles and Approach I Episode 142: Microsoft Research project Orleans simplify development of scalable cloud services Orleans: Thinking Big and Small Available Now: Preview of Project “Orleans” – Cloud Services at Scale Orleans: Distributed Virtual Actors for Programmability and Scalability By others Introducing Orleans Microsoft Orleans v2.0 - A comprehensive guide for beginners and experts alike (PowerPoint) A First Look at Project Orleans A Second Look at Project Orleans Project Orleans: An Introduction Introduction To Project Orleans Introduction to Orleans Project Orleans: Different Than Erlang, Designed for a Broad Group of Developers Two Reasons You May Want to Use Microsoft’s Project Orleans Hatay Tuna & Christian Martinez - Applied Actor Model with Orleans Actor Programming with Orleans: What’s Different? Orleans – a “cloud native” runtime built for #azure Project Orleans - Actor Model framework A look at Microsoft Orleans through Erlang-tinted glasses Using Codename “Orleans” in Enterprise Applications Beyond the introduction Grains, Grains and more Grains Fine-graining your Orleans Grains inside the IoT universe Monitorable Grains Aggregating Results in Orleans Creating RESTful Services using Orleans Tackle Distribution, High Throughput and Low-Latency with Orleans – A “cloud native” Runtime Built for #Azure Saving state only once in a while in #ProjectOrleans Using Orleans for building scalable cloud applications Orleans in an IoT universe Orleans Preview & Halo 4 Using Project “Orleans” in Halo Orleans & Thinking Outside the Box John Azariah & Mahesh Krishnan - Immutability, State and Scale - Functional, Distributed Applications in Azure last edited: 5 June 2018"
  },
  "Community/Orleans-Architecture-Principles-and-Approach-I.html": {
    "href": "Community/Orleans-Architecture-Principles-and-Approach-I.html",
    "title": "Orleans Architecture - Principles and Approach I | Microsoft Orleans Website",
    "keywords": "Now that Orleans is (finally) available as open source, it's important to be clear about the goals and principles that has motivated the design decisions behind Orleans so that new changes either fit within that framework or explicitly and intentionally revise those goals and principles. About the time I joined the Orleans project, we agreed that the goal was to produce a framework that would allow mainstream developers to easily build scalable distributed (cloud) applications. To break this down a bit: The target audience shouldn't exclude programmers who haven't done distributed systems development . We want to enable all developers, whether cloud experts or cloud beginners, to focus on their application logic and features -- which is to say, what actually provides business value -- rather than on generic distributed systems issues. The goal is to allow them to build cloud applications easily . Easily means that they shouldn't have to think about distribution any more than is absolutely required. Easily also means that Orleans should present as familiar a façade to the developer as possible; in a .NET context, that means C# objects and interfaces. Those applications should be \"scalable by default\" . Since our target users aren't necessarily distributed systems experts, we want to provide them a framework that will lead them to build scalable applications without explicitly thinking about it. This means that the framework has to make a lot of decisions for them in order to guarantee an acceptable degree of scalability, even if that means that the scalability isn't optimal for every application. We supplemented this goal with a set of architectural principles: We're focused on the 80% case . There are certainly applications that Orleans isn't appropriate for; that's OK. There are applications that Orleans is a reasonable fit for, but where you can get somewhat better performance by a bunch of hand-tuning that Orleans doesn't allow; that's OK too. The 80% that Orleans fits well and performs well enough on covers a lot of interesting applications, and we'd rather do a great job on 80% than a lousy job on 99%. Scalability is paramount . We'll trade off raw performance if that gets us better scaling. Availability is paramount . A cloud application should be like a utility: always there when you want it. Detect and fix problems , don't assume you can 100% prevent them. At cloud scale, bad things happen often, and even impossible bad things happen, just less often. This has led us to what is often termed \"recovery-oriented computing\", rather than trying to be fault-tolerant; our experience has shown that fault tolerance is fragile and often illusory. Even mathematically proven protocols are no protection against random bit flips in memory or disk controllers that fail while reporting success -- both real examples I've seen in production in my career. The above has led us to certain practices: API-first design : if we don't know how we're going to expose a feature to the developer, then we don't build it. Of course, the best way is for a feature have no developer exposure at all... Make it easy to do the right thing : keep things as simple as possible (but no simpler), don't provide a hammer if a screwdriver is the right tool. As one of our early adopters put it, we try to help our customers \"fall into the pit of success\". If there is a standard pattern that will work well for 80% of the applications out there, then don't worry about enabling every possible alternative. Orleans' embrace of asynchrony is a good example of this. Make it easy for developers to extend the framework without breaking it . Custom serialization and persistence providers are a couple of examples of this. Some sort of custom task scheduling extension would be an anti-example. Follow the principle of least surprise : as much as possible, things should be as familiar, but everything should behave the way it looks. The next post will start applying these principles to the current Orleans design and walk through the motivations for some specific decisions we made. Thanks for reading! Alan Geller Alan Geller, http://research.microsoft.com/en-us/people/ageller/ , works on quantum computing at Microsoft Research. He was one of the primary architects of Orleans from 2008 until 2012. Earlier, he was the platform architect for Amazon Web Services from 2004 to 2008, and before that built a wide variety of large-scale production distributed systems in telecommunications and financial services."
  },
  "Community/Orleans-Thinking-Big-and-Small.html": {
    "href": "Community/Orleans-Thinking-Big-and-Small.html",
    "title": "Orleans - Thinking Big and Small | Microsoft Orleans Website",
    "keywords": "TL;DR: You don’t need hundreds of servers to benefit from Orleans. A handful is enough. As we just announced availability of the Project Orleans as a public preview ( Available Now: Preview of Project “Orleans” – Cloud Services at Scale ), some of the initial questions and discussions at //build/ were around what type of services the Orleans programming model is suitable for. I heard statements that Orleans is for super-high scale systems. While technically correct, they felt incomplete to me, and compelled me to write this post. Applicability Spectrum One extreme of the Orleans applicability spectrum is a single machine application. Some people see isolation of actors and safe concurrency as big enough benefits that they are worth the price of message passing. That’s not the use case we optimized for while building Orleans, but it’s a legitimate usage pattern, just not very interesting in the cloud context. At the other end of the spectrum we find massive deployments that span thousands of servers. We tested Orleans on deployments of hundreds of servers, and I’m sure it will run fine on thousands, even if that will require some configuration tweaks. However, I’m personally rather skeptical about how many products actually need a single cloud service spanning thousands of servers as opposed to running multiple related services interacting with each other where each service instance is deployed on tens or hundreds of servers. Distributed system – same problems regardless of the size The moment a system moves from a single server to multiple servers, developers face very much the same set of challenges, regardless of its size -- whether it's a 3-5, 30-50 or 300-500 server system. They now have to deal with distribution of their computations, coordination between them, scalability, fault tolerance and reconfigurations, diagnostics, etc. They are building a distributed system now, which is never easy. And building a stateful distributed system is even harder. Orleans was designed to help with building such systems by providing an easy to use set of abstractions that greatly simplifies developers’ lives and helps them avoid common distributed systems pitfalls. The distributed runtime was built to perform most of the heavy lifting. Developers can equally benefit from these features of Orleans when building services of different sizes because the problems Orleans solves for them are really the same. The abstraction of grains simplifies reasoning about your system while encouraging fine-grain partitioning of state for scalability. The virtual actor feature helps with resource management and fault tolerance. Automatic propagation of exceptions minimizes error handling code without losing failures. The distributed runtime takes care of server failures, messaging, routing, single-threaded execution, and other system level guarantees. You don’t need hundreds of servers to start reaping the developer productivity gains. Elasticity Predicting load for your future system is hard and often simply impossible. Every startup dreams of getting slashdotted one day, which is a blessing for the business and a curse for the system. Or your CMO may like your BI data so much that she suddenly wants to have it in 5 second aggregates instead of 30 minutes. Building for high load that may never materialize is expensive. The Orleans model helps solve the elasticity problem by encouraging designing your system in a scalable way, so that you can start with a small deployment and stay small or scale out big if needed without changing your application code. Bottom Line You should be able to benefit from Orleans the moment you go from a single-server setup to a distributed system, whether it’s 2 or 3 servers or thousands of them. You can even start building your single-server solution with Orleans if you believe you may need one day scale it out or make fault tolerant. The beauty here is that your code won’t need to change. Just add more servers and your grains will spread across them. -Sergey Bykov"
  },
  "Community/Student-Projects.html": {
    "href": "Community/Student-Projects.html",
    "title": "Student Projects | Microsoft Orleans Website",
    "keywords": "Student Projects We suggest 2 types of projects for students: The first type includes exploratory, open-ended, research-oriented projects with the goal of enabling new capabilities in Orleans. These projects would usually have broad scope and would be suitable for M.S. or Ph.D. student or advanced undergraduate students in their last year of studies. The end goal of these projects would be to contribute ideas and design to Orleans. We do not necessarily expect the code produced in these projects to be directly contributed to this repository, however this would be nice. The second type includes ideas for student education . These are either ideas for interesting applications that can be built on top of Orleans or some new capabilities for Orleans. These projects are suitable to be given in advanced undergraduate or graduate courses, where students learn about Cloud Computing and modern distributed technologies and want to gain real-world hands-on experience in building Cloud applications. We do not expect the code produced in these projects to be contributed directly to this repository. Research projects: Auto-scale. In this project students can start by exploring the existing auto-scaling mechanisms for controlling resource allocation in Windows Azure ( Autoscaling Application Block ). The next step involves exploring various statistics and resource consumption metrics collected by Orleans, and using them as an input for Azure Autoscaling. An advanced stage of this project may involve improving the internal Orleans mechanisms for reacting to elasticity changes, for example by implementing live actor migration to reduce the time taken to utilize new resources. Auto-generated front-ends for Orleans-based cloud services . This project seamlessly extends the Orleans actor model into the HTTP world. The ramp-up part of the project includes dynamically generating HTTP endpoints for actors based on their .NET interfaces and metadata. The main part involves automatically generating front-ends to support web sockets and bi-directional streaming of data, which requires complex code generation with optimizations for high performance. It also requires attention to fault tolerance, to maintain high availability of streaming sessions across server reboots and client reconnects and migration -- a significant research challenge. Storage provider for Entity Framework . This project involves enabling Orleans objects to store their state in a database and to subsequently query it. This might include adding support for Orleans object persistence on SQL Azure Database using Entity Framework (EF), which is Microsoft's open-source object-relational mapper for .NET, and exposing that data via LINQ queries. The implementation can be evaluated and tuned using standard database benchmarks and/or custom Orleans' applications. Distributed system benchmark . Define a list of benchmarks suitable for distributed systems like Orleans. The benchmark applications may be analogous in spirit to the TPC database benchmark or UCB \"Parallel Dwarfs\" implemented here and may be used to characterize the performance and scalability of distributed frameworks. Consider developing a new benchmark targeted for Orleans, for example, to compare the performance of storage providers. Declarative dataflow language over streams . Define and build a Trident-Storm like declarative language over Orleans streams. Develop an optimizer that configures the stream processing to minimize overall cost. Programming model for client devices . Extend Orleans to client devices, such as sensors, phones, tablets, and desktops. Enable grain logic to execute on the client. Potentially support tier splitting, that is, dynamically deciding which parts of the code execute on the device and which is offloaded to the cloud. Queries over grain/actor classes, secondary indices . Build a distributed, scalable, and reliable grain index. This includes formally defining the query model and implementing the distributed index. The index itself can be implemented as Orleans grains and/or stored in a database. Large scale simulations . Orleans is a great fit for building large scale simulations. Explore the usage of Orleans for different simulations, for example, protein interactions, network simulations, simulated annealing, etc. Course projects: Internet Of Things applications . For example, the application could enable sensors/devices to report their state to the cloud, where each device is represented in the cloud by an Orleans actor. Users can connect to the actor that represents their device via a web browser and check its status or control it. This project involves mastering a number of modern cloud technologies, including Windows Azure , Orleans, WebApi or ASP.NET, SignalR for streaming commands back from the cloud to the device, and writing a sensor/device/phone app. Twitter-like large scalable chat service in the cloud based on Orleans . Each user could be represented by an Orleans Actor, which contains its list of followers. Faceboook-like social app based on Orleans . Each user could be represented by an Orleans Actor, which includes a list of friends and wall on which friends can write. Simple storage provider . Add a storage provider for a storage system, such as a key-value store or database system. A simple one could use the Orleans serializer , as in the existing Azure Table storage provider . A more sophisticated one would map state variables of an Orleans class to fine-grained structures of the storage system. A complex one is the Entity Framework storage provider mentioned above under Research Projects . Compare the performance of different storage providers for different types and sizes of actor state. Comparison with other distributed application frameworks . Take a sample application written for another application framework, such as Google App Engine or Akka , and translate it into Orleans. Summarize the relative strengths and weaknesses of each framework by comparing the apps. Concluded Research projects: Below are a number of examples of previous successful research projects. Distributed log analysis, correlation and debugging . Debugging large-scale distributed systems is a challenging task due to enormous amounts of data and complex dynamic interactions between the distributed components, running on different processes and different machines. The goal of this project was to analyze prior art on this topic, propose a solution, and then implement prototype tools for collecting, correlating and analyzing application error log file data across a multi-machine distributed application runtime environment. This involved exploring the problem space from a variety of perspectives, including: a. Approaches to efficient logging, collection and analysis of failure information from various log-capture mechanisms in a distributed Orleans runtime environment. b. Possible applications of machine learning to find log patterns that signal serious production issues, and then detecting these patterns in near real time as a production monitoring utility. c. Ways to help individual developers perform real-time debugging of run-time issues with their applications. This project was performed successfully and result in a published paper PAD: Performance Anomaly Detection in Multi-Server Distributed Systems and a proof of concept implementation of a distributed log analysis tool. Horton - Distributed Graph Database . Horton was a research project with a goal to build a system to store, manage and query large-scale distributed graphs. It was implemented entirely as an Orleans application. The project resulted in a number of publications and a number of very successful student projects."
  },
  "Community/Who-Is-Using-Orleans.html": {
    "href": "Community/Who-Is-Using-Orleans.html",
    "title": "Who Is Using Orleans? | Microsoft Orleans Website",
    "keywords": "Who Is Using Orleans? Orleans has been used extensively by several Microsoft projects and product groups, most notably by 343 Industries as a platform for all of Halo 4 and Halo 5 cloud services. There are various other internal projects at Microsoft which are using Orleans, but we are not able to talk publicly about many of those yet. There are many more companies and projects which are also using Orleans, and this page provides a partial list of some that we know about.... Feel free to send us a pull request on GitHub to add your company / project to this list. Companies Companies currently using Orleans in production: Gassumo Microsoft Skype , Azure , others Microsoft Studios 343 Studios ( Halo ), Age of Empires , BigPark , Black Tusk , others Microsoft Research NašeÚkoly.CZ Trustev Mailcloud Limited Gigya Honeywell Mesh Systems MESHVista Smart Cloud IoT Platform leverages Orleans for back-end services monitoring device state and business logic Applicita Limited A number of client projects where extreme scale and performance is required Drawboard Cloud collaboration and synchronisation platform YouScan Social media monitoring & analytics provider. Orleans is used for stateful stream processing at scale, reliable execution of long running jobs and as a main application server. Visa PagoLivre Mobile and Social Payment platform invertirOnline.com Argentinian-based electronic brokerage firm Lebara Nomnio Nomnio IoT Platform and industry projects where reliability and performance is required Real Artists Ship 2.0 Fast, native, comprehensive issue tracking for GitHub Manufacturing Resources International MRI designs, engineers, and fabricates BoldVu® LCD displays used in out of home advertising networks. Orleans powers our IOT infrastructure to help monitor and maintain our displays Projects and Applications Projects, websites and applications powered by Orleans, or provide extensions to Orleans. Claw (Clash Of Animal Warriors) is a real-time multiplayer mobile game which uses Orleans for its MatchMaker software which should handle many players at the same time and respond to them as fast as possible. Halo 4 - 343 Industries Microsoft BigPark Studio Orleans-Contrib Community contribution projects, including Orleans Monitoring, Design Patterns, Storage Provider, etc. Pegasus Mission More Info here and here Sync.Today 2015 .NET Business Processes Automation Platform. More info here Microdot A microservices framework by Gigya, for writing Orleans based microservices"
  },
  "Community/Documentation-Guidelines.html": {
    "href": "Community/Documentation-Guidelines.html",
    "title": "Documentation Guidelines | Microsoft Orleans Website",
    "keywords": "Documentation Guidelines The Orleans documentation is built in Markdown . We use a few simple conventions to ensure a homogeneous style throughout the full set of documents. These standards are being introduced. If you have issues with these guidelines then raise an issue or a Pull Request. If you find documentation that fails to meet the guidelines, then make a fix and submit a pull request. Also if you are using windows 10 you can go to the store and find free MarkDown editors like this Structure Language The documentation will follow US-English spelling. Desktop tools like http://markdownpad.com have spell checking features. Paragraph structure Each sentence should be written on a single line, and only one sentence per line. This makes merging changes easier and also helps identify verbose language. Paragraphs in Markdown are just one or more lines of consecutive text followed by one or more blank lines. Headings Heading should be used to structure a document. Avoid using other emphasis features like ALLCAPS, Italics or bold to identify a new topic. Using a header is not only more consistent, but also allows linking to the header. Footers At the end of a page, it is helpful to link to the next logical page in the documentation. If the page is the last in a sub-section then linking back to the index page is useful. Styles Code formatting Blocks of example code should be formatted with the triple back tick format followed by the language ``` csharp [StorageProvider(ProviderName=\"store1\")] public class MyGrain<IMyGrainState> ... { ... } ``` Which will render as [StorageProvider(ProviderName=\"store1\")] public class MyGrain<IMyGrainState> ... { ... } Inline code should be marked with a single backtick (`). This include references to: type names e.g. Task<T> variable names e.g. game namespaces e.g. Orleans.Storage.AzureTableStorage If showing text that is an output (e.g. text file content or console output) you can either use the triple back tick without specifying a language or you can indent the content. For example: 1 said: Welcome to my team! 0 said: Thanks! 1 said: Thanks! 0 said: Thanks! File names and paths When referencing a filename, directory/folder or URI then use standard italics to format. This can be done by surrounding the string with either with a single asterisk ( * ) or a single underscore ( _ ) Examples: OrleansRuntimeInterfaces.dll C:\\Binaries ../src/Grain.cs Tables Markdown supports tabular data . Tables could be used to structure data so that is is easily consumable for the reader. Suffix Unit ms millisecond(s) s second(s) m minute(s) Links When referencing another concept, the concept should be linked to. Forward and backward references with in a page can be linked to via the header. e.g. link back to Structure Links to other documents can either link to the page, or a sub-section/header within the page. External links should be exposed as a the full link e.g. https://github.com/dotnet/roslyn Contribution The Orleans documentation is managed as Markdown files in a Git repository hosted on GitHub in the gh-pages branch . See the GitHub Pages documentation on how to use the gh-pages branch convention for \"Project site\" documents."
  },
  "Tutorials/Custom-Grain-Storage.html": {
    "href": "Tutorials/Custom-Grain-Storage.html",
    "title": "Custom Grain Storage | Microsoft Orleans Website",
    "keywords": "Custom Grain Storage Writing a Custom Grain Storage In the tutorial on declarative actor storage, we looked at allowing grains to store their state in an Azure table using one of the built-in storage providers. While Azure is a great place to squirrel away your data, there are many alternatives. In fact, there are so many that there was no way to support them all. Instead, Orleans is designed to let you easily add support for your own form of storage by writing a grain storage. In this tutorial, we'll walk through how to write a simple file-based grain storage. A file system is not the best place to store grains states as it is local, there can be issues with file locks and the last update date is not sufficient to prevent inconsistency. But it's an easy example to help us illustrate the implementation of a Grain Storage . Getting Started An Orleans grain storage is a class that implements IGrainStorage which is included in Microsoft.Orleans.Core NuGet package . We also inherit from ILifecycleParticipant<ISiloLifecycle> which will allow us to subscribe to a particular event in the lifecycle of the silo. We start by creating a class named FileGrainStorage . using Orleans; using System; using Orleans.Storage; using Orleans.Runtime; using System.Threading.Tasks; namespace GrainStorage { public class FileGrainStorage : IGrainStorage, ILifecycleParticipant<ISiloLifecycle> { private readonly string _storageName; private readonly FileGrainStorageOptions _options; private readonly ClusterOptions _clusterOptions; private readonly IGrainFactory _grainFactory; private readonly ITypeResolver _typeResolver; private JsonSerializerSettings _jsonSettings; public FileGrainStorage(string storageName, FileGrainStorageOptions options, IOptions<ClusterOptions> clusterOptions, IGrainFactory grainFactory, ITypeResolver typeResolver) { _storageName = storageName; _options = options; _clusterOptions = clusterOptions.Value; _grainFactory = grainFactory; _typeResolver = typeResolver; } public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { throw new NotImplementedException(); } public void Participate(ISiloLifecycle lifecycle) { throw new NotImplementedException(); } public void Participate(ISiloLifecycle lifecycle) { throw new NotImplementedException(); } } } Prior starting the implementation, we create an option class containing the root directory where the grains states files will be stored under. For that we will create an options file FileGrainStorageOptions : public class FileGrainStorageOptions { public string RootDirectory { get; set; } } The create a constructor containing two fields, storageName to specify which grains should write using this storage [StorageProvider(ProviderName = \"File\")] and directory which would be the directory where the grain states will be saved. IGrainFactory , ITypeResolver will be used in the next section where we will initilize the storage. We also take two options as argument, our own FileGrainStorageOptions and the ClusterOptions . Those will be needed for the implementation of the storage functionalities. We also need JsonSerializerSettings as we are serializing and deserializing in Json format. Json is an implementation detail, it is up to the developer to decide what serialization/deserialization protocol would fit the application. Another common format is binary format. Initializing the storage To initialize the storage, we register an Init function on the ApplicationServices lifecycle. public void Participate(ISiloLifecycle lifecycle) { lifecycle.Subscribe(OptionFormattingUtilities.Name<FileGrainStorage>(_storageName), ServiceLifecycleStage.ApplicationServices, Init); } The Init function is used to set the _jsonSettings which will be used to configure the Json serializer. At the same time we create the folder to store the grains states if it does not exist yet. private Task Init(CancellationToken ct) { // Settings could be made configurable from Options. _jsonSettings = OrleansJsonSerializer.UpdateSerializerSettings(OrleansJsonSerializer.GetDefaultSerializerSettings(_typeResolver, _grainFactory), false, false, null); var directory = new System.IO.DirectoryInfo(_rootDirectory); if (!directory.Exists) directory.Create(); return Task.CompletedTask; } We also provide a common function to construct the filename ensuring uniqueness per service, grain Id and grain type. private string GetKeyString(string grainType, GrainReference grainReference) { return $\"{_clusterOptions.ServiceId}.{grainReference.ToKeyString()}.{grainType}\"; } Reading State To read a grain state, we get the filename using the function we previously defined and combine it to the root directory coming from the options. public async Task ReadStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (!fileInfo.Exists) { grainState.State = Activator.CreateInstance(grainState.State.GetType()); return; } using (var stream = fileInfo.OpenText()) { var storedData = await stream.ReadToEndAsync(); grainState.State = JsonConvert.DeserializeObject(storedData, _jsonSettings); } grainState.ETag = fileInfo.LastWriteTimeUtc.ToString(); } We use the fileInfo.LastWriteTimeUtc as a ETag which will be used by other functions for inconsistency checks to prevent data loss. Note that for the deserialization, we use the _jsonSettings which was set on the Init function. This is important to be able to serialize/deserialize properly the state. Writing State Writing the state is similar to reading the state. public async Task WriteStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var storedData = JsonConvert.SerializeObject(grainState.State, _jsonSettings); var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (fileInfo.Exists && fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag) { throw new InconsistentStateException($\"Version conflict (WriteState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.\"); } using (var stream = new StreamWriter(fileInfo.Open(FileMode.Create, FileAccess.Write))) { await stream.WriteAsync(storedData); } fileInfo.Refresh(); grainState.ETag = fileInfo.LastWriteTimeUtc.ToString(); } Similarly as reading, we use _jsonSettings to write the state. The current ETag is used to check against the last updated time in UTC of the file. If the date is different, it means that another activation of the same grain changed the state concurrently. In this situation, we throw an InconsistentStateException which will result in the current activation being killed to prevent overwritting the state previously saved by the other activated grain. Clearing State Clearing the state would be deleting the file if the file exists. public Task ClearStateAsync(string grainType, GrainReference grainReference, IGrainState grainState) { var fName = GetKeyString(grainType, grainReference); var path = Path.Combine(_options.RootDirectory, fName); var fileInfo = new FileInfo(path); if (fileInfo.Exists) { if (fileInfo.LastWriteTimeUtc.ToString() != grainState.ETag) { throw new InconsistentStateException($\"Version conflict (ClearState): ServiceId={_clusterOptions.ServiceId} ProviderName={_storageName} GrainType={grainType} GrainReference={grainReference.ToKeyString()}.\"); } grainState.ETag = null; grainState.State = Activator.CreateInstance(grainState.State.GetType()); fileInfo.Delete(); } return Task.CompletedTask; } For the same reason as WriteState , we check for inconsistency before proceeding to delete the file and reset the ETag, we check if the current ETag is the same as the last write time UTC. Putting it Together After that we will create a factory which will allow us to scope the options setting to the provider name and at the same time create an instance of the FileGrainStorage to ease the registration to the service collection. public static class FileGrainStorageFactory { internal static IGrainStorage Create(IServiceProvider services, string name) { IOptionsSnapshot<FileGrainStorageOptions> optionsSnapshot = services.GetRequiredService<IOptionsSnapshot<FileGrainStorageOptions>>(); return ActivatorUtilities.CreateInstance<FileGrainStorage>(services, name, optionsSnapshot.Get(name), services.GetProviderClusterOptions(name)); } } Lastly to register the grain storage, we create an extension on the ISiloHostBuilder which internally register the grain storage as a named service using .AddSingletonNamedService(...) , an extension provided by Orleans.Core . public static class FileSiloBuilderExtensions { public static ISiloHostBuilder AddFileGrainStorage(this ISiloHostBuilder builder, string providerName, Action<FileGrainStorageOptions> options) { return builder.ConfigureServices(services => services.AddFileGrainStorage(providerName, options)); } public static IServiceCollection AddFileGrainStorage(this IServiceCollection services, string providerName, Action<FileGrainStorageOptions> options) { services.AddOptions<FileGrainStorageOptions>(providerName).Configure(options); return services .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create) .AddSingletonNamedService(providerName, (s, n) => (ILifecycleParticipant<ISiloLifecycle>)s.GetRequiredServiceByName<IGrainStorage>(n)); } } Our FileGrainStorage implements two interfaces, IGrainStorage and ILifecycleParticipant<ISiloLifecycle> therefore we need to register two named services for each interfaces: return services .AddSingletonNamedService(providerName, FileGrainStorageFactory.Create) .AddSingletonNamedService(providerName, (s, n) => (ILifecycleParticipant<ISiloLifecycle>)s.GetRequiredServiceByName<IGrainStorage>(n)); This enables us to add the file storage using the extension on the ISiloHostBuilder : var silo = new SiloHostBuilder() .UseLocalhostClustering() .AddFileGrainStorage(\"File\", opts => { opts.RootDirectory = \"C:/TestFiles\"; }) .Build(); Now we will be able to decorate our grains with the provider [StorageProvider(ProviderName = \"File\")] and it will store in the grain state in the root directory set in the options."
  },
  "index.html": {
    "href": "index.html",
    "title": "Microsoft Orleans | Microsoft Orleans Website",
    "keywords": ""
  }
}