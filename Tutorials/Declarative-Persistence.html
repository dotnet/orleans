<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Declarative Persistence | Microsoft Orleans Website </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Declarative Persistence | Microsoft Orleans Website ">
    <meta name="generator" content="docfx 2">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../Images/logo-light.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="declarative-persistence">Declarative Persistence</h1>

<p>In the second tutorial, we saw how grain state survived the client being shut down, which opens up for a lot of cache-like scenarios, where Orleans is relied upon as a kind of &#39;cache with behavior,&#39; an object-oriented cache, if you will.
That is already very valuable and goes a long way toward achieving server-side scalability with a simple, familiar, programming model and the built-in single-threaded execution guarantees.</p>
<p>However, it is sometimes the case that some of the state you are accumulating belongs in some form of permanent storage, so that it can survive a silo shutdown, or a grain migrating from one silo to another for load-balancing or a complete restart/shutdown of the service. What we have seen so far will not support such situations.</p>
<p>Fortunately, Orleans offers a simple declarative model for identifying the state that needs to be stored in a permanent location, while leaving the decision when to save and restore state under programmatic control.
You are not required to use the declarative persistence mechanism and can still access storage directly from your grain code, but it’s a nice way to save you some boilerplate code and build applications that are portable across various storage services.</p>
<h2 id="getting-started">Getting Started</h2>
<p>We&#39;ll continue to build on our employee-and-manager sample.</p>
<p>The first thing we need to do is make the identities of our workers and managers a little more predictable.
In the sample, they were assigned GUIDs using <code>Guid.NewGuid()</code>, which is convenient, but doesn&#39;t let us find them in a subsequent run.
Therefore, we&#39;ll create a set of GUIDs first, then use them as the worker identities.</p>
<p>The modified client program looks like this:</p>
<pre><code class="lang-csharp">private static async Task DoClientWork(IClusterClient client)
{
     ...
    var ids = new string[] {
        &quot;42783519-d64e-44c9-9c29-399e3afaa625&quot;,
        &quot;d694a4e0-1bc3-4c3f-a1ad-ba95103622bc&quot;,
        &quot;9a72b0c6-33df-49db-ac05-14316edd332d&quot;,
        &quot;6526a751-b9ac-4881-9bfb-836ecce2ca9f&quot;,
        &quot;ae4b106f-3c96-464a-b48d-3583ed584b17&quot;,
        &quot;b715c40f-d8d2-424d-9618-76afbc0a2a0a&quot;,
        &quot;5ad92744-a0b1-487b-a9e7-e6b91e9a9826&quot;,
        &quot;e23a55af-217c-4d76-8221-c2b447bf04c8&quot;,
        &quot;2eef0ac5-540f-4421-b9a9-79d89400f7ab&quot;
    };

    var e0 = client.GetGrain&lt;IEmployee&gt;(Guid.Parse(ids[0]));
    var e1 = client.GetGrain&lt;IEmployee&gt;(Guid.Parse(ids[1]));
    var e2 = client.GetGrain&lt;IEmployee&gt;(Guid.Parse(ids[2]));
    var e3 = client.GetGrain&lt;IEmployee&gt;(Guid.Parse(ids[3]));
    var e4 = client.GetGrain&lt;IEmployee&gt;(Guid.Parse(ids[4]));

    var m0 = client.GetGrain&lt;IManager&gt;(Guid.Parse(ids[5]));
    var m1 = client.GetGrain&lt;IManager&gt;(Guid.Parse(ids[6]));
     ...
}
</code></pre><blockquote><p>Note: If you are transitioning from Orleans 1.5, you will notice that the Client is no longer static.
Please refer to <a href="../Documentation/Migration/Migration1.5.html">Migration from Orleans 1.5 to 2.0</a> page.</p>
</blockquote>
<p>Next, we&#39;ll do some silo configuration, in order to configure the storage provider that will give us access to persistent storage.
The SiloHost project includes a file <em>Program.cs</em> which is where we find the following section:</p>
<pre><code class="lang-csharp">var builder = new SiloHostBuilder()
                .UseLocalhostClustering()
                .Configure&lt;EndpointOptions&gt;(options =&gt; options.AdvertisedIPAddress = IPAddress.Loopback)
                .ConfigureLogging(logging =&gt; logging.AddConsole());

var host = builder.Build();
await host.StartAsync();
return host;
</code></pre><p>If this is hosted in Azure Cloud Services, then one can use either of the following before calling <code>builder.Build()</code> to use Azure to persist grain state:</p>
<pre><code class="lang-csharp">// Stores grains as composition of fields
builder.AddAzureTableGrainStorage(option =&gt; option.ConnectionString = your_connection_string);
// Stores grains as blobs
builder.AddAzureBlobGrainStorage(option =&gt; option.ConnectionString = your_connection_string);
</code></pre><p>The <code>MemoryStorage</code> provider is fairly uninteresting, since it doesn&#39;t actually provide any permanent storage; it&#39;s intended for debugging persistent grains while having no access to a persistent store.
In our case, that makes it hard to demonstrate persistence, so we will rely on a real storage provider.</p>
<p>Depending on whether you have already set up (and want to use) an Azure storage account, or would like to rely on the Azure storage emulator, you should add one of the other two lines, but not both. You can use either the <code>AddAzureTableStorageProvider()</code> function or the <code>AddAzureBlobStorageProvider()</code> function depending on how you want to store information.</p>
<p>In the case of the former, you have to start the Azure storage emulator after installing the latest version of the Azure SDK.
In the case of the latter, you will have to create a Azure storage account and enter the name and keys in the configuration file.</p>
<p>With one of those enabled, we&#39;re ready to tackle the grain code.</p>
<blockquote><p>Note: With Orleans 2.0, a lot of functionality have been split off into smaller packages to allow more granular configuration and deployment.
This includes the Azure storage provider.
Please install <a href="https://www.nuget.org/packages/Microsoft.Orleans.Persistence.AzureStorage/">Orleans.Persistence.AzureStorage</a> package if you would like to use Azure as a storage provider.
You could find some of the other storage providers maintained by the Orleans community by <a href="https://www.nuget.org/packages?q=Microsoft.Orleans.Persistence">searching for Orleans.Persistence</a>.</p>
</blockquote>
<h2 id="declaring-state">Declaring State</h2>
<p>Identifying that a grain should use persistent state takes three steps:</p>
<ol>
<li>declaring a class for the state,</li>
<li>changing the grain base class, and</li>
<li>identifying the storage provider.</li>
</ol>
<p>The first step, declaring a state class in the grain implementations project, simply means identifying the information of an actor that should be persisted and creating what looks like a record of the persistent data -- each state component is represented by a property with a getter and a setter.</p>
<p>For employees, we want to persist all the state:</p>
<pre><code class="lang-csharp">public class  EmployeeState
{
    public int Level { get; set; }
    public IManager Manager { get; set; }
}
</code></pre><p>and for managers, we must store the direct reports, but the <code>_me</code> reference may continue to be created during activation.</p>
<pre><code class="lang-csharp">public class ManagerState
{
    public List&lt;IEmployee&gt; Reports { get; set; }
}
</code></pre><p>Then, we change the grain class declaration to identify the state interface (e.g., from <code>Orleans.Grain</code> to <code>Orleans.Grain&lt;EmployeeState&gt;</code>) and remove the variables that we want persisted. Make sure to remove <code>level</code>, and <code>manager</code> from the <code>Employee</code> class and <code>_reports</code> from the <code>Manager</code> class. In addition, we must update the other functions to reflect these removals.</p>
<p> We also add an attribute to identify the storage provider:</p>
<pre><code class="lang-csharp">[StorageProvider(ProviderName = &quot;AzureStore&quot;)]
public class Employee : Orleans.Grain&lt;EmployeeState&gt;, Interfaces.IEmployee
</code></pre><p>and</p>
<pre><code class="lang-csharp">[StorageProvider(ProviderName=&quot;AzureStore&quot;)]
public class Manager : Orleans.Grain&lt;ManagerState&gt;, IManager
</code></pre><p>At risk of stating the obvious, the name of the storage provider attribute should match the name as it was used in configuring the Silo.
This indirection is what allows you to delay choices around where to store grain state until deployment.</p>
<p>Given these declarative changes, the grain should no longer rely on a private fields to keep compensation level and manager.
Instead, the grain base class gives us access to the state via a <code>State</code> property that is available to the grain.</p>
<p>For example:</p>
<pre><code class="lang-csharp">public Task SetManager(IManager manager)
{
   State.Manager = manager;
   return TaskDone.Done;
}
</code></pre><h2 id="controlling-checkpoints">Controlling Checkpoints</h2>
<p>The question that remains is when the persistent state gets saved to the storage provider.</p>
<p>One choice that the Orleans designers could have made would be to have the runtime save state after every method invocation, but that turns out to be undesirable because it is far too conservative -- not all invocations will actually modify the state on all invocations, and some will never modify it. Rather than employing a complex system to evaluate state differentials after each method, Orleans asks the grain developer to add the necessary logic to determine whether state needs to be saved or not.</p>
<p>Saving the state using the storage provider is easily accomplished by calling <code>base.WriteStateAsync()</code>.</p>
<p>Thus, the final version of the <code>Promote()</code> and <code>SetManager()</code> methods looks like this:</p>
<pre><code class="lang-csharp">public Task Promote(int newLevel)
{
    State.Level = newLevel;
    return base.WriteStateAsync();
}

public Task SetManager(IManager manager)
{
    State.Manager = manager;
    return base.WriteStateAsync();
}
</code></pre><p>In the <code>Manager</code> class, there&#39;s only one method that need to be modified to write out data, <code>AddDirectReport()</code>.
It should look like this:</p>
<pre><code class="lang-csharp">public async Task AddDirectReport(IEmployee employee)
{
    if (State.Reports == null)
    {
        State.Reports = new List&lt;IEmployee&gt;();
    }
    State.Reports.Add(employee);
    await employee.SetManager(this);
    var data = new GreetingData { From = this.GetPrimaryKey(), Message = &quot;Welcome to my team!&quot; };
    await employee.Greeting(data);
    Console.WriteLine(&quot;{0} said: {1}&quot;,
                        data.From.ToString(),
                        data.Message);

    await base.WriteStateAsync();
}
</code></pre><p>Let&#39;s try this out!</p>
<p>Set a breakpoint in <code>Employee.Promote()</code>.</p>
<p>When we run the client code the first time and hit the breakpoint, the level field should be <code>0</code> and the newLevel parameter either <code>10</code> or <code>11</code>:</p>
<p><img src="../Images/Persistence%202.PNG" alt=""></p>
<p>Let the application finish (reach the &#39;Hit Enter...&#39; prompt) and exit.
Run it again, and compare what happens when you look at state this second time around:</p>
<p><img src="../Images/Persistence%203.PNG" alt=""></p>
<h2 id="just-making-sure">Just Making Sure...</h2>
<p>It&#39;s worth checking what Azure thinks about the data.
Using a storage explorer such as Azure Storage Explorer (ASE) or the one built in to Server Explorer in Visual Studio 2013, open the storage account (or developer storage of the emulator) and find the &#39;OrleansGrainState&#39; table.
It should look something like this (you have to hit &#39;Query&#39; in ASE):</p>
<p><img src="../Images/Persistence%204.PNG" alt=""></p>
<p>If everything is working correctly, the grain keys should appear in the <code>PartitionKey</code> column, and the qualified class name of the grains should appear in the <code>RowKey</code> column.</p>
<h2 id="mixing-things">Mixing Things</h2>
<p>A grain may contain a combination of persisted and transient state.
Any transient state should be represented by private fields in the grain class.
A common use for mixing the two is to cache some computed version of the persisted state in private fields while it is present in memory.
For example, a stack of elements may be externally represented as a <code>List&lt;T&gt;</code>, but internally, as a <code>Stack&lt;T&gt;</code>.</p>
<p>In the case of our <code>Manager</code> class, the <code>_me</code> field is simply a cached value, something we don&#39;t even need to keep as a field in the first place, it can be created any time we need it, but since it&#39;s going to be a commonly used value, it&#39;s worth keeping it around in a transient field.</p>
<h2 id="automatic-loading-of-state">Automatic loading of state</h2>
<p>If a grain type has state, at activation time the state will be loaded from storage and then <code>OnActivateAsync</code> is called so you can be sure that the state is loaded when initializing your grain. This is the only case that Orleans calls <code>ReadStateAsync</code> automatically. If you want to write the state or read it in some other place, you should do it on your own. Normally you should not need to call <code>ReadStateAsync</code> yourself unless you are doing something specific regarding handling corrupted state or something else.</p>
<h2 id="handling-failures-using-persistence">Handling failures using persistence</h2>
<p>Generally speaking reading and writing a grain&#39;s state is a good mechanism to handle failures as well as serving its original intent.
There is a possibility that your grain call fails in the middle of a method due to different reasons and you end up with a state which is half changed.
In this case reading from storage can return your state to the last correct state.
Alternatively, having gotten into such a state, the grain can request to get immediately deactivated by calling  DeactivateOnIdle(), so that its a next request to it would trigger reactivation of the grain, which would reread the persistent state and reconstruct its in-memory copy.
Deactivation is the cleanest way of resetting a grain to its last know good state, but if you want to avoid the cost of the reactivation process, you can reset its state and rerun any initialization logic (for example, by calling <code>OnActivateAsync</code>) instead of deactivating the grain.</p>
<h2 id="next">Next</h2>
<p>Next, we&#39;ll see how we can call our grains from an MVC web application.</p>
<p><a href="../1.5/Tutorials/Failure-Handling.html">Handling Failure</a></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/orleans/blob/gh-pages/src/Tutorials/Declarative-Persistence.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
