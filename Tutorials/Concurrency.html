<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Concurrency | Microsoft Orleans Website </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Concurrency | Microsoft Orleans Website ">
    <meta name="generator" content="docfx 2.8.0.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="docfx:rel" content="../">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../Images/logo-light.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <h1 id="concurrency">Concurrency</h1>
              
<p>Please read about <a href="../Documentation/Getting-Started-With-Orleans/Grains.html">Grains</a> before following this tutorial.</p>
<p>Let&#39;s go back to the code that was established in the tutorial on collections of actors and modify it to demonstrate how things can go bad by creating a trivial cycle in the messaging graph: when an employee receives a greeting, he sends another greeting back to the sender and waits for the acknowledgment.
This will send a back-and-forth series of messages, until we get to 3.</p>
<p>First create a class in the interface project which we&#39;ll use to send the greetings around:</p>
<pre><code class="lang-csharp">public class GreetingData
{
    public Guid From { get; set; }
    public string Message { get; set; }
    public int Count { get; set; }
}
</code></pre><p><code>From</code> will be the sender of the message (the ID of the grain), <code>Message</code> will be the message text, and <code>Count</code> will be the number of times the message has been sent back and forth.
This stops us from getting a stack overflow.</p>
<p>We need to modify the arguments of <code>Greeting</code> on the <code>IEmployee</code> interface to :</p>
<pre><code class="lang-csharp">Task Greeting(GreetingData data);
</code></pre><p> We need to update the implementation accordingly:</p>
<pre><code class="lang-csharp">public async Task Greeting(GreetingData data)
{
    Console.WriteLine(&quot;{0} said: {1}&quot;, data.From, data.Message);

    // stop this from repeating endlessly
    if (data.Count &gt;= 3) return;

    // send a message back to the sender
    var fromGrain = GrainFactory.GetGrain&lt;IEmployee&gt;(data.From);
    await fromGrain.Greeting(new GreetingData {
        From = this.GetPrimaryKey(),
        Message = &quot;Thanks!&quot;,
        Count = data.Count + 1 });
}
</code></pre><p> We&#39;ll also update the <code>Manager</code> class, so it send the new message object:</p>
<pre><code class="lang-csharp">public async Task AddDirectReport(IEmployee employee)
{
    _reports.Add(employee);
    await employee.SetManager(this);
    await employee.Greeting(new GreetingData {
        From = this.GetPrimaryKey(),
        Message = &quot;Welcome to my team!&quot; });
}
</code></pre><p>Now the Employee sends a message back to the manager, saying &quot;Thanks!&quot;.</p>
<p>Let&#39;s add some simple client code to add a direct report to a manager:</p>
<pre><code class="lang-csharp">var e0 = GrainClient.GrainFactory.GetGrain&lt;IEmployee&gt;(Guid.NewGuid());
var m1 = GrainClient.GrainFactory.GetGrain&lt;IManager&gt;(Guid.NewGuid());
m1.AddDirectReport(e0).Wait();
</code></pre><p>When we run this code, the first &quot;Thanks!&quot; greeting is received.
However, when this message is responded to this we get a 30 second pause (or 10 minutes when the debugger is attached), then warnings appear in the log and we&#39;re told the grain is about to break it&#39;s promise.</p>
<pre><code>    7b66f830-8d81-49fc-b8fc-279af6924bd3 said: Welcome to my team!
    ce14310a-8500-4b2f-a21b-b4b23eb48d0d said: Thanks!    
[2014-03-12 15:25:37.398 GMT    31      WARNING 100157  CallbackData    127.0.0.1:11111]        Response did
not arrive on time in 00:00:30 for message: Request
S127.0.0.1:11111:132333898*grn/906ECA4C/00000001@68e2b3ab-&gt;S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187 #13: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: &lt;S127.0.0.1:11111:132333898:*grn/D9BB797F/00000000:@c24c4187&gt;.
 About to break its promise.
 [2014-03-12 15:25:37.398 GMT    27      WARNING 100157  CallbackData    127.0.0.1:11111]        Response did not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187-&gt;S127.0.0.1:11111:132333898*grn/D9BB797F/00000001@afc70cb4 #14: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: &lt;S127.0.0.1:11111:132333898:*grn/D9BB797F/00000001:@afc70cb4&gt;. About to break its promise.
[2014-03-12 15:25:37.407 GMT    28      WARNING 100157  CallbackData    127.0.0.1:11111]        Response did  not arrive on time in 00:00:30 for message: Request S127.0.0.1:11111:132333898*grn/D9BB797F/00000001@afc70cb4-&gt;S127.0.0.1:11111:132333898*grn/D9BB797F/00000000@c24c4187 #15: MyGrainInterfaces1.IEmployee:Greeting(). Target History is: &lt;S127.0.0.1:11111:132333898:*grn/D9BB797F/00000000:@c24c4187&gt;. About to break its promise.
</code></pre><p>An exception is then thrown in the client code.</p>
<p>We&#39;ve created a deadlock.
Grain 0 sends a message to grain 1.
In that call grain 1 sends a message back to grain 0.
However, grain 0 can&#39;t process it because it&#39;s awaiting the first message, so it gets queued.
The await can&#39;t complete until the second message is returned, so we&#39;ve entered a state that we can&#39;t escape from.
Orleans waits for 30 seconds (10 minutes with the debugger), then kills the request.</p>
<p>Orleans offers us a way to deal with this, by marking the grain <code>[Reentrant]</code>, which means that additional calls may be made while the grain is waiting for a task to complete, resulting in interleaved execution.</p>
<pre><code class="lang-csharp">[Reentrant]
public class Employee : Grain, IEmployee
{
    ...
}
</code></pre><p>We see that the sample works, and Orleans is able to interleave the grain calls:</p>
<pre><code> aaadb551-7dde-4dbe-82ce-1a5f2547babe said: Welcome to my team!
 63e4d07c-ac50-4012-ba50-5b5cf54e4e45 said: Thanks!
 aaadb551-7dde-4dbe-82ce-1a5f2547babe said: Thanks!
 63e4d07c-ac50-4012-ba50-5b5cf54e4e45 said: Thanks!
</code></pre><h2 id="messages">Messages</h2>
<p>Messages are simply data passed from one actor to another, we just created the <code>GreetingData</code> class to do just this.</p>
<p>In .NET, most objects are created from a class of some sort and are passed around by reference, something that doesn&#39;t work well with concurrency, and definitely not with distribution.</p>
<p>When Orleans sends a message from one grain to another, it creates a deep copy of the object, and provides the copy to the second grain, and not the object stored in the first grain.
This prohibits the mutation of state from one grain to another, one of the main tenets in the actor model is that state shouldn&#39;t be shared, and message passing is the only mechanism for exchanging data.</p>
<p>When the grains are in different silos, the object model is serialized to a binary format, and sent over the wire.</p>
<p>However, this deep copy process is expensive, and if you promise not to modify the message, then for communication with grains within a silo, it&#39;s unnecessary.</p>
<p>If you indicate to Orleans that you are not going to modify the object (i.e. it&#39;s immutable) then it can skip the deep copy step, and it will pass the object by reference.
There&#39;s no way Orleans or C# can stop you from modifying the state, you have to be disciplined.</p>
<p>Immutability is indicated with a the <code>[Immutable]</code> attribute on the class:</p>
<pre><code class="lang-csharp">[Immutable]
public class GreetingData
{
    public Guid From { get; set; }
    public string Message { get; set; }
    public int Count { get; set; }
}
</code></pre><p>No other code change is required, this is just a signal to give to Orleans to tell it your not going to modify this object.</p>
<h2 id="next">Next</h2>
<p>Next, we&#39;ll see how we can interact with external services from inside our grain.</p>
<p><a href="Interaction-with-Libraries-and-Services.html">Interaction with Libraries and Services</a></p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/orleans/blob/gh-pages/src/Tutorials/Concurrency.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2016 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
