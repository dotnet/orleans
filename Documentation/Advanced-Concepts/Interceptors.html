<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Interceptors | Microsoft Orleans Website </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Interceptors | Microsoft Orleans Website ">
    <meta name="generator" content="docfx 2.3.1.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    <meta property="docfx:rel" content="../../">
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../Images/logo-light.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
              <a href="https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Advanced-Concepts/Interceptors.md/#L1" class="btn btn-primary pull-right mobile-hide">Improve this Doc</a>
              <h1 id="interceptors">Interceptors</h1>
              
<p>Orleans provides a way to intercept grain invocation calls and inject an arbitrary application logic into the invocation path.</p>
<h2 id="client-side-interceptors">Client side interceptors</h2>
<p>If client side interceptor is defined, any grain call made from Orleans client will invoke this interceptor before the call is dispatched remotely. The interceptor is invoked synchronously in the same thread where the call is made after call arguments were deep copied. Since the interceptor is invoked synchronously it should return promptly and do a minimum work, to avoid blocking calling thread or impacting throughput. The interceptor is allowed to mutate the call arguments and also mutate the <a href="http://dotnet.github.io/orleans/Advanced-Concepts/Request-Context"><code>Orleans.RequestContext</code></a>. Any changes made by the interceptor to <code>Orleans.RequestContext</code> will be picked up as part of the call dispatch logic that occurs after the interceptor. If the interceptor logic throws an exception, the remote call will not be made and the client calling code will throw promptly.</p>
<p>The interceptor can be set by setting <code>GrainClient.ClientInvokeCallback</code>, which is a property of type <code>Action&lt;InvokeMethodRequest, IGrain&gt;</code>. The first argument is the invocation request that includes varios details about the invoked call, such as InterfaceId and MethodId, as well as deep-copied arguments. The second argument is the target grain reference to which this call is made.</p>
<p>Currently, the main scenario that we know of that uses client side pre-call inteceptors is to add some extra information to <a href="http://dotnet.github.io/orleans/Advanced-Concepts/Request-Context"><code>Orleans.RequestContext</code></a>, such as any special call context or token.</p>
<h2 id="server-side-interceptors">Server side interceptors</h2>
<p>There are two methods for performing method interception on the server-side:</p>
<ol>
<li>Silo-level interceptors</li>
<li>Grain-level interceptors</li>
</ol>
<p>As their names suggest, they operate on all grain calls, and an individual grain class&#39; calls respectively. The two methods can be used in the same silo. In that case, the silo-level interceptor will be called before the grain-level interceptor.</p>
<h3 id="silo-level-interceptors">Silo-level Interceptors</h3>
<p>Silo-level interceptors are called for all grain calls within a silo. They can be installed using <code>IProviderRuntime.SetInvokeInterceptor(interceptor)</code>, typically from within a <a href="https://dotnet.github.io/orleans/Advanced-Concepts/Application-Bootstrap-within-a-Silo">Bootstrap Provider</a>&#39;s <code>Init</code> method, like so:</p>
<pre><code class="lang-csharp">providerRuntime.SetInvokeInterceptor(async (method, request, grain, invoker) =&gt;
{
    log.LogInfo($&quot;{grain.GetType()}.{method.Name}(...) called&quot;);

    // Invoke the request and return the result back to the caller.
    var result = await invoker.Invoke(grain, request);
    log.LogInfo($&quot;Grain method returned {result}&quot;);
    return result;
});
</code></pre><p>Note how the interceptor wraps the call to the grain. This allows the user to inspect the return value of each method as well as handle any exceptions which are thrown.</p>
<p><code>SetInvokeInterceptor</code> takes a single parameter, a delegate of type <code>InvokeInterceptor</code> with the following signature:</p>
<pre><code class="lang-csharp">public delegate Task&lt;object&gt; InvokeInterceptor(MethodInfo targetMethod, InvokeMethodRequest request, IGrain target, IGrainMethodInvoker invoker);
</code></pre><p>In this delegate:</p>
<ul>
<li><code>targetMethod</code> is the <code>MethodInfo</code> of the method being called on the grain implementation, not the interface.</li>
<li><code>request.Arguments</code> is an <code>object[]</code> containing the arguments to the method, if any.</li>
<li><code>target</code> is the grain implementation instance being called.</li>
<li><code>invoker</code> is used to invoke the method itself.</li>
</ul>
<h3 id="grain-level-interceptors">Grain-level interceptors</h3>
<p>Grain-level interceptors intercept calls for individual grains only. Grain-level interceptors are enabled by implementing <code>IGrainInvokeInterceptor</code> in a grain class:</p>
<pre><code class="lang-csharp">public interface IGrainInvokeInterceptor
{
    Task&lt;object&gt; Invoke(MethodInfo method, InvokeMethodRequest request, IGrainMethodInvoker invoker);
}
</code></pre><p>For example:</p>
<pre><code class="lang-csharp">public Task&lt;object&gt; Invoke(MethodInfo methodInfo, InvokeMethodRequest request, IGrainMethodInvoker invoker)
{
    // Check access conditions.
    var isAdminMethod = methodInfo.GetCustomAttribute&lt;AdminOnlyAttribute&gt;();
    if (isAdminMethod &amp;&amp; !(bool)RequestContext.Get(&quot;isAdmin&quot;))
    {
      throw new AccessDeniedException($&quot;Only admins can access {methodInfo.Name}!&quot;);
    }

    return invoker.Invoke(this, request);
}
</code></pre><p>If a silo-level interceptor is also present, the grain-level interceptor is invoked inside of silo-level interceptors, during the call to <code>invoker.Invoke(...)</code>. Grain-level interceptors will also be invoked for grain extensions (implementations of <code>IGrainExtension</code>), not only for method in the current class.</p>

            </article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
            <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
            </nav>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright Â© 2015-2016 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
