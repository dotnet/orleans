<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>External Tasks and Grains | Microsoft Orleans Website </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="External Tasks and Grains | Microsoft Orleans Website ">
    <meta name="generator" content="docfx 2">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../Images/logo-light.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items"></div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="external-tasks-and-grains">External Tasks and Grains</h1>

<p>By design, any sub-Tasks spawned from grain code (for example, by using <code>await</code> or <code>ContinueWith</code> or <code>Task.Factory.StartNew</code>) will be dispatched on the same per-activation <a href="https://msdn.microsoft.com/en-us/library/dd997402(v=vs.110).aspx">TPL Task Scheduler</a> as the parent task and therefore inherit the same single-threaded execution model as the rest of grain code. This is the main point behind single threaded execution of <a href="http://dotnet.github.io/orleans/Tutorials/Concurrency">grain turn based concurency</a>.</p>
<p>In some cases grain code might need to “break out” of the Orleans task scheduling model and “do something special”, such as explicitly pointing a <code>Task</code> to a different task scheduler or using the .NET Thread pool. An example of such cases is when grain code has to execute a synchronous remote blocking call (such as remote IO). Doing that in the grain context will block the grain as well as one of the Orleans threads and thus should never be made. Instead, the grain code can execute this piece of blocking code on the thread pool thread and join (<code>await</code>) the completion of that execution and proceed in the grain context. We expect that escaping from the Orleans scheduler will be a very advanced and seldom required usage scenario beyond the “normal” usage patterns.</p>
<h3 id="task-based-apis">Task based APIs:</h3>
<p>1) <code>await</code>, <code>Task.Factory.StartNew</code>, <code>Task.ContinuewWith</code>, <code>Task.WhenAny</code>, <code>Task.WhenAll</code>, <code>Task.Delay</code> all respect the current Task Scheduler. That means that using them in the default way, without passing a different TaskScheduler, will cause them to execute in the grain context.</p>
<p>2) Both <code>Task.Run</code> and the <code>endMethod</code> delegate of <code>Task.Factory.FromAsync</code> do NOT respect the current task Scheduler. They both use the <code>TaskScheduler.Default</code> scheduler, which is the .NET thread pool task Scheduler. Therefore, the code inside <code>Task.Run</code> and the <code>endMethod</code> will ALWAYS run on the .NET thread pool outside of the single-threaded execution model for Orleans grains, <a href="http://blogs.msdn.com/b/pfxteam/archive/2011/10/24/10229468.aspx">as detailed here</a>. However, any code after the <code>await Task.Run</code> or <code>await Task.Factory.FromAsync</code> will run back under the scheduler at the point the task was created, which is the grain scheduler.</p>
<p>3) <code>configureAwait(false)</code> is an explicit API to escape the current task Scheduler. It will cause the code after an awaited Task to be executed on the <code>TaskScheduler.Default</code> scheduler, which is the .NET thread pool, and will thus break the single-threaded execution of the Orleans grain. You should in general <strong>never ever use <code>configureAwait(false)</code> directly in grain code.</strong></p>
<p>4) Methods with signature <code>async void</code> should not be used with grains. They are intended for graphical user interface event handlers.</p>
<h3 id="example">Example:</h3>
<p>Below is sample code that demonstrates the usage of <code>TaskScheduler.Current</code>, <code>Task.Run</code> and a special custom scheduler to escape from Orlean grain context and how to get back to it.</p>
<pre><code class="lang-csharp">   public async Task MyGrainMethod()
   {
        // Grab the Orleans task scheduler
        var orleansTs = TaskScheduler.Current;
        await TaskDelay(10000);
        // Current task scheduler did not change, the code after await is still running in the same task scheduler.
        Assert.AreEqual(orleansTs, TaskScheduler.Current);

        Task t1 = Task.Run( () =&gt;
        {
             // This code runs on the thread pool scheduler, not on Orleans task scheduler
             Assert.AreNotEqual(orleansTS, TaskScheduler.Current);
             Assert.AreEqual(TaskScheduler.Default, TaskScheduler.Current);
        } );
        await t1;
        // We are back to the Orleans task scheduler. 
        // Since await was executed in Orleans task scheduler context, we are now back to that context.
        Assert.AreEqual(orleansTS, TaskScheduler.Current);

        // Example of using ask.Factory.StartNew with a custom scheduler to escape from the Orleans scheduler
        Task t2 = Task.Factory.StartNew(() =&gt;
        {
             // This code runs on the MyCustomSchedulerThatIWroteMyself scheduler, not on the Orleans task scheduler
             Assert.AreNotEqual(orleansTS, TaskScheduler.Current);
             Assert.AreEqual(MyCustomSchedulerThatIWroteMyself, TaskScheduler.Current);
        },
        CancellationToken.None, TaskCreationOptions.None,
        scheduler: MyCustomSchedulerThatIWroteMyself);
        await t2;
        // We are back to Orleans task scheduler.
        Assert.AreEqual(orleansTS, TaskScheduler.Current);
   }
</code></pre><h3 id="advanced-example---making-a-grain-call-from-code-that-runs-on-a-thread-pool">Advanced Example - making a grain call from code that runs on a thread pool</h3>
<p>An even more advanced scenario is a piece of grain code that needs to “break out” of the Orleans task scheduling model and run on a thread pool (or some other, non-Orleans context), but still needs to call another grain. If you try to make a grain call but are not within an Orleans context, you will get an exception that says you are &quot;trying to send a message on a silo not from within a grain and not from within a system target (RuntimeContext is not set to SchedulingContext)&quot;.</p>
<p>Below is code that demonstrates how a grain call can be made from a piece of code that runs inside a grain but not in the grain context.</p>
<pre><code class="lang-csharp">   public async Task MyGrainMethod()
   {
        // Grab the Orleans task scheduler
        var orleansTs = TaskScheduler.Current;
        Task&lt;int&gt; t1 = Task.Run(async () =&gt;
        {
             // This code runs on the thread pool scheduler, not on Orleans task scheduler
             Assert.AreNotEqual(orleansTS, TaskScheduler.Current);
             // You can do whatever you need to do here. Now let&#39;s say you need to make a grain call.
             Task&lt;Task&lt;int&gt;&gt; t2 = Task.Factory.StartNew(() =&gt;
             {
                // This code runs on the Orleans task scheduler since we specified the scheduler: orleansTs.
                Assert.AreEqual(orleansTS, TaskScheduler.Current);
                return GrainFactory.GetGrain&lt;IFooGrain&gt;(0).MakeGrainCall();
             }, CancellationToken.None, TaskCreationOptions.None, scheduler: orleansTs);

             int res = await (await t2); // double await, unrelated to Orleans, just part of TPL APIs.
             // This code runs back on the thread pool scheduler, not on the Orleans task scheduler
             Assert.AreNotEqual(orleansTS, TaskScheduler.Current);
             return res;
        } );

        int result = await t1;
        // We are back to the Orleans task scheduler.
        // Since await was executed in the Orleans task scheduler context, we are now back to that context.
        Assert.AreEqual(orleansTS, TaskScheduler.Current);
   }
</code></pre><h3 id="dealing-with-libraries">Dealing with libraries</h3>
<p>Some external libraries that your code is using might be using <code>ConfigureAwait(false)</code> internally. In fact, it is a good and correct practice in .NET to use <code>ConfigureAwait(false)</code> <a href="https://msdn.microsoft.com/en-us/magazine/jj991977.aspx">when implementing general purpose libraries</a>. This is not a problem in Orleans. As long as the code in the grain that invokes the library method is awaiting the library call with a regular <code>await</code>, the grain code is correct. The result will be exactly as desired -- the library code will run continuations on the Default scheduler (which happens to be <code>ThreadPoolTaskScheduler</code> but it does not guarantee that the continuations will definitely run on a ThreadPool thread, as continuations are often inlined in the previous thread), while the grain code will run on the Orleans scheduler.</p>
<p>Another frequently-asked question is whether there is a need to execute library calls with <code>Task.Run</code> -- that is, whether there is a need to explicitly offload the library code to ThreadPool (for grain code to do <code>Task.Run(()=&gt; myLibrary.FooAsync())</code>). The answer is No. There is no need to offload any code to ThreadPool, except for the case of library code that is making a blocking synchronous calls. Usually, any well-written and correct .NET async library (methods that return <code>Task</code> and are named with an <code>Async</code> suffix) do not make blocking calls. Thus there is no need to offload anything to ThreadPool, unless you suspect the async library is buggy or if you are deliberately using a synchronous blocking library.</p>
<h2 id="summary">Summary</h2>
<table>
<thead>
<tr>
<th>What are you trying to do?</th>
<th>How to do it</th>
</tr>
</thead>
<tbody>
<tr>
<td>Run background work on .NET thread-pool threads. No grain code or grain calls allowed.</td>
<td><code>Task.Run</code></td>
</tr>
<tr>
<td>Grain interface call</td>
<td>Method return types = <code>Task</code> or <code>Task&lt;T&gt;</code></td>
</tr>
<tr>
<td>Run worker task from grain code with Orleans turn-based concurrency guarantees.</td>
<td><code>Task.Factory.StartNew</code></td>
</tr>
<tr>
<td>Timeouts for executing work items</td>
<td><code>Task.Delay</code> + <code>Task.WhenAny</code></td>
</tr>
<tr>
<td>Use with <code>async</code>/<code>await</code></td>
<td>The normal .NET Task-Async programming model. Supported &amp; recommended</td>
</tr>
<tr>
<td><code>ConfigureAwait(false)</code></td>
<td>Do not use inside grain code. Allowed only inside libraries.</td>
</tr>
<tr>
<td>Calling async library</td>
<td><code>await</code> the library call</td>
</tr>
</tbody>
</table>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/orleans/blob/gh-pages/src/Documentation/Advanced-Concepts/External-Tasks-and-Grains.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Copyright © 2015-2017 Microsoft<br>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
