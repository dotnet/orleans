<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
var maxArgsCount = 8;
#>
// <auto-generated />
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Text;

#pragma warning disable

namespace Orleans.CodeGeneration
{
<#
for (int i = 1; i <= maxArgsCount; i++)
{
	var typeArgs = string.Join(", ", from t in Enumerable.Range(1, i) select "T" + t);
#>
	[Serializable]
	[StructLayout(LayoutKind.Auto)]
	public struct GrainCallArguments<<#= typeArgs #>> : IGrainCallArguments
	{
<# for (int j = 1; j <= i; j++) { #>
		public T<#= j #> Item<#= j #>;

<#} #>
		public GrainCallArguments(<#= string.Join(", ", from t in Enumerable.Range(1, i) select string.Format("T{0} item{0}", t)) #>)
		{
<# for (int j = 1; j <= i; j++) { #>
			Item<#= j #> = item<#= j #>;
<#} #>
		}

		public object this[int index]
		{
			get
			{
				switch(index)
				{
<# for (int j = 0; j < i; j++) { #>
					case <#= j #>:
						return Item<#= j + 1 #>;
<#} #>
					default:
						throw new ArgumentOutOfRangeException();
				}
			}

			set
			{
				switch(index)
				{
<# for (int j = 0; j < i; j++) { #>
					case <#= j #>:
						Item<#= j + 1 #> = (T<#= j + 1 #>)value;
						break;
<#} #>
					default:
						throw new ArgumentOutOfRangeException();
				}
			}
		}
		
		public int Length => <#= i #>;

        int IReadOnlyCollection<object>.Count => Length;

        public Enumerator GetEnumerator() => new Enumerator(this);

        IEnumerator<object> IEnumerable<object>.GetEnumerator() => GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Visit<TContext>(IGrainCallArgumentVisitor<TContext> vistor, TContext context)
        {
<# for (int j = 1; j <= i; j++) { #>
			vistor.Visit(ref Item<#= j #>, context);
<#} #>
        }

        public struct Enumerator : IEnumerator<object>
        {
            private readonly GrainCallArguments<<#= typeArgs #>> _args;
            private int _index;
            private object _current;

            public object Current => _current;

            internal Enumerator(GrainCallArguments<<#= typeArgs #>> args)
            {
                _args = args;
                _index = 0;
                _current = null;
            }

            public void Dispose()
            {
            }

            public bool MoveNext()
            {
				if(_index < <#= i #>)
				{
					_current = _args[_index];
					_index++;
					return true;
				}

                return false;
            }

            public void Reset()
            {
                _index = 0;
				_current = null;
            }
        }
	}

<#
}
#>
	public partial struct GrainCallArguments
	{
<#
for (int i = 1; i <= maxArgsCount; i++)
{
	var typeArgs = string.Join(", ", from t in Enumerable.Range(1, i) select "T" + t);
	var args = string.Join(", ", from t in Enumerable.Range(1, i) select string.Format("T{0} item{0}", t));
	var @params = string.Join(", ", from t in Enumerable.Range(1, i) select "item" + t);
#>
		public static GrainCallArguments<<#= typeArgs #>> Create<<#= typeArgs #>>(<#= args #>) =>
			new GrainCallArguments<<#= typeArgs #>>(<#= @params #>);

<#
}
#>
		public static Type GetGenericDefinition(int argumentsCount)
		{
			switch(argumentsCount)
			{
				case 0:
					return typeof(GrainCallArguments);
<# for (int i = 1; i <= maxArgsCount; i++) { #>
				case <#= i #>:
					return typeof(GrainCallArguments<<#= string.Concat(Enumerable.Repeat(",", i - 1)) #>>);
<#} #>
				default:
					throw new ArgumentOutOfRangeException();
			}
		}
	}
}