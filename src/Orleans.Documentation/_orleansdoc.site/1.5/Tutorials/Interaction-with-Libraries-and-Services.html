<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Interaction with Libraries and Services | Microsoft Orleans Documentation </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Interaction with Libraries and Services | Microsoft Orleans Documentation ">
    <meta name="generator" content="docfx 2">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../Images/logo-light.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="interaction-with-libraries-and-services">Interaction with Libraries and Services</h1>

<p>Code running in a grain is not prohibited from calling external systems or services, but the rule for always using asynchronous code must be maintained.</p>
<p>In this sample we&#39;ll see how a grain can call out to an external service.</p>
<h2 id="creating-a-stock-grain">Creating a Stock Grain</h2>
<p>For this sample, let&#39;s create a grain which maintains the current price for a stock.</p>
<p>Create a grain interface project, and add an interface for an <code>IStockGrain</code>:</p>
<pre><code class="lang-csharp">public interface IStockGrain : Orleans.IGrainWithStringKey
{
    Task&lt;string&gt; GetPrice();
}
</code></pre><p>Note, we&#39;ve opted for an string-based key for our grain, which is useful since the ticker symbol makes a natural key.
The <code>IGrainWithStringKey</code> interface is new in the September refresh.
Now add a grain implementation project, and add a reference to the interface project.
Add a reference to <code>System.Net.Http</code>.</p>
<p>We&#39;ll implement the grain so it retrieves the price of the stock when it is activated:</p>
<pre><code class="lang-csharp">public class StockGrain : Orleans.Grain, IStockGrain
{
    string price;

    public override async Task OnActivateAsync()
    {
        string stock;
        this.GetPrimaryKey(out stock);
        await UpdatePrice(stock);
        await base.OnActivateAsync();
    }

    async Task UpdatePrice(string stock)
    {
        price = await GetPriceFromYahoo(stock);
    }

    async Task&lt;string&gt; GetPriceFromYahoo(string stock)
    {
        var uri = &quot;http://download.finance.yahoo.com/d/quotes.csv?f=snl1c1p2&amp;e=.csv&amp;s=&quot; + stock;
        using (var http = new HttpClient())
        using (var resp = await http.GetAsync(uri))
        {
            return await resp.Content.ReadAsStringAsync();
        }
    }

    public Task&lt;string&gt; GetPrice()
    {
        return Task.FromResult(price);
    }
}
</code></pre><p>Next create some client code to connect to the Orleans Silo, and retrieve the grain state:</p>
<pre><code class="lang-csharp">Console.WriteLine(&quot;Waiting for Orleans Silo to start. Press Enter to proceed...&quot;);
Console.ReadLine();

var config = Orleans.Runtime.Configuration.ClientConfiguration.LocalhostSilo(30000);
GrainClient.Initialize(config);

// retrieve the MSFT stock
var grain = GrainClient.GrainFactory.GetGrain&lt;IStockGrain&gt;(&quot;MSFT&quot;);
var price = grain.GetPrice().Result;
Console.WriteLine(price);

Console.ReadLine();
</code></pre><p>When we start the local silo, and run the application, we should see the stock value written out</p>
<pre><code> &quot;MSFT&quot;,&quot;Microsoft Corpora&quot;,37.70,-0.19,&quot;-0.50%&quot;
</code></pre><p>Note that the extra text in the stock price is just the formatting that Yahoo! returned.</p>
<h2 id="refreshing-the-value-with-a-timer">Refreshing the value with a timer</h2>
<p>The problem with the grain as it stands is that the value of the stock will change, but the grain will maintain the same value for it&#39;s lifetime (an indefinite period of time).</p>
<p>One way to fix this is to periodically refresh the price.</p>
<p>A traditional .NET timer is not suitable for running in a grain.
Instead, Orleans provides it&#39;s own timer.</p>
<p>Let&#39;s re-factor the <code>OnActivateAsync()</code> method to introduce a timer which will call the <code>UpdatePrice</code> method in 1 minute, and then repeatedly every minute from then on, until the grain is deactivated:</p>
<pre><code class="lang-csharp">public override async Task OnActivateAsync()
{
    string stock;
    this.GetPrimaryKey(out stock);
    await UpdatePrice(stock);

    var timer = RegisterTimer(
        UpdatePrice,
        stock,
        TimeSpan.FromMinutes(1),
        TimeSpan.FromMinutes(1));

    await base.OnActivateAsync();
}
</code></pre><p>We&#39;ll also have to slightly adjust the <code>UpdatePrice</code> method, as the stock argument must be an object rather than a string.
We&#39;ll also add some logging so we can see what&#39;s happening:</p>
<pre><code class="lang-csharp">async Task UpdatePrice(object stock)
{
    price = await GetPriceFromYahoo(stock as string);
    Console.WriteLine(price);
}
</code></pre><p>The <code>RegisterTimer</code> method takes four arguments:</p>
<ul>
<li><code>callback</code> - A function to call.</li>
<li><code>state</code> - An object to pass as the first argument of the callback function (this can be null).</li>
<li><code>dueTime</code> - The period to wait before starting the first call to <code>callback</code>.</li>
<li><code>period</code> - The period between subsequent calls to <code>callback</code>.</li>
</ul>
<p>Note: In our sample we&#39;re passing the stock name as the  state argument when we register the timer.
This means the stock name is presented to the <code>UpdatePrice</code> method as the argument.
Alternative we could set state to be <code>null</code>, and read the stock name from inside <code>UpdatePrice</code> using <code>GetPrimaryKey</code>.
The method returns an <code>IOrleansTimer</code> which is disposable and can be used to stop the timer.
It&#39;s a good idea to hold on to a reference to this in case you need to stop the timer.</p>
<p>Now when we run the sample, the grain is activated, the timer gets registered and every minute the price is updated for us:</p>
<pre><code>&quot;MSFT&quot;,&quot;Microsoft Corpora&quot;,37.70,-0.19,&quot;-0.50%&quot;

&quot;MSFT&quot;,&quot;Microsoft Corpora&quot;,37.70,-0.19,&quot;-0.50%&quot;

&quot;MSFT&quot;,&quot;Microsoft Corpora&quot;,37.70,-0.19,&quot;-0.50%&quot;

&quot;MSFT&quot;,&quot;Microsoft Corpora&quot;,37.70,-0.19,&quot;-0.50%&quot;
</code></pre><p>Orleans is acting as an automatically refreshing cache.
Whenever a stock grain is queried Orleans will provide the latest price it has, without having to make a call to the stock web service.</p>
<h2 id="parallelization">Parallelization</h2>
<p>Running code in a single threaded execution model, does not prohibit you from awaiting several tasks at once (or in parallel).</p>
<p>Let&#39;s add a new function to retrieve the graph data for a stock:</p>
<pre><code class="lang-csharp">async Task&lt;string&gt; GetYahooGraphData(string stock)
{
    // retrieve the graph data from Yahoo finance
    var uri = string.Format(
        &quot;http://chartapi.finance.yahoo.com/instrument/1.0/{0}/chartdata;type=quote;range=1d/csv/&quot;,stock);
    using (var http = new HttpClient())
    using (var resp = await http.GetAsync(uri))
    {
        return await resp.Content.ReadAsStringAsync();
    }
}
</code></pre><p>We&#39;ll also add a new field to the grain to store this information:</p>
<pre><code class="lang-csharp">string graphData;
</code></pre><p>Now we can retrieve the graph data and current price like this:</p>
<pre><code class="lang-csharp">async Task UpdatePrice(object stock)
{
    price = await GetPriceFromYahoo(stock as string);
    graphData = await GetYahooGraphData(stock as string);
    Console.WriteLine(price);
}
</code></pre><p>However, by doing this we&#39;re waiting for the price from Yahoo, and after that&#39;s complete we request the graph data.
This is inefficient, as we could be doing these at the same time.
Fortunately, <code>Task</code> has a convenient <code>WhenAll</code> method which allows us to await multiple tasks at once, allowing these tasks to complete in parallel.</p>
<pre><code class="lang-csharp">async Task UpdatePrice(object stock)
{
    // collect the task variables without awaiting
    var priceTask = GetPriceFromYahoo(stock as string);
    var graphDataTask = GetYahooGraphData(stock as string);

    // await both tasks
    await Task.WhenAll(priceTask, graphDataTask);

    // read the results
    price = priceTask.Result;
    graphData = graphDataTask.Result;
    Console.WriteLine(price);
}
</code></pre><p>Note: The <code>Result</code> of a <code>Task</code> will block execution if the task hasn&#39;t completed.
This should be avoided in Orleans, tasks should always be awaited before <code>Result</code> is read.</p>
<p>Note: When a large number of asynchronous actions need to happen simultaneously you can collect the tasks in a <code>List&lt;Task&lt;T&gt;&gt;</code> and present this to <code>Task.WhenAll</code>.</p>
<h2 id="external-tasks">External Tasks</h2>
<p>It&#39;s tempting to use the <a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library</a> <em>&quot;TPL&quot;</em> for executing parallel tasks in Orleans, but TPL uses the .NET thread pool to dispatch tasks. This is prohibited within grain code.</p>
<p>Orleans has its own task scheduler which provides the single threaded execution model used within grains. 
It&#39;s important that when running tasks the Orleans scheduler is used, and not the .NET thread pool.</p>
<p>Should your grain code require a sub-task to be created, you should use <code>Task.Factory.StartNew</code>:</p>
<pre><code class="lang-csharp">await Task.Factory.StartNew(() =&gt;{ /* logic */ });
</code></pre><p>This technique will use the current task scheduler, which will be the Orleans scheduler.</p>
<p>You should avoid using <code>Task.Run</code>, which always uses the .NET thread pool, and therefore will not run in the single-threaded execution model.</p>
<h2 id="next">Next</h2>
<p>Let&#39;s look at how Orleans can persist grain state for us:</p>
<p><a href="Declarative-Persistence.html">Declarative Persistence</a></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
