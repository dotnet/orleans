//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Orleans.Serialization.TestKit
{
    [Xunit.Trait("Category", "BVT")]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public abstract partial class CopierTester<TValue, TCopier>
        where TCopier : class, Cloning.IDeepCopier<TValue>
    {
        protected CopierTester(Xunit.Abstractions.ITestOutputHelper output) { }

        protected virtual bool IsImmutable { get { throw null; } }

        protected virtual bool IsPooled { get { throw null; } }

        protected System.Random Random { get { throw null; } }

        protected System.IServiceProvider ServiceProvider { get { throw null; } }

        protected abstract TValue[] TestValues { get; }

        protected virtual System.Action<System.Action<TValue>> ValueProvider { get { throw null; } }

        [Xunit.Fact]
        public void CanCopyCollectionViaSerializer() { }

        [Xunit.Fact]
        public void CanCopyCollectionViaUntypedSerializer() { }

        [Xunit.Fact]
        public void CanCopyTupleViaSerializer() { }

        [Xunit.Fact]
        public void CanCopyUntypedTupleViaSerializer() { }

        protected virtual void Configure(ISerializerBuilder builder) { }

        [Xunit.Fact]
        public void CopiedValuesAreEqual() { }

        protected virtual TCopier CreateCopier() { throw null; }

        protected abstract TValue CreateValue();
        protected virtual bool Equals(TValue left, TValue right) { throw null; }

        [Xunit.Fact]
        public void ReferencesAreAddedToCopyContext() { }
    }

    [Xunit.Trait("Category", "BVT")]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public abstract partial class FieldCodecTester<TValue, TCodec> : System.IDisposable where TCodec : class, Codecs.IFieldCodec<TValue>
    {
        protected FieldCodecTester(Xunit.Abstractions.ITestOutputHelper output) { }

        protected virtual int[] MaxSegmentSizes { get { throw null; } }

        protected System.Random Random { get { throw null; } }

        protected System.IServiceProvider ServiceProvider { get { throw null; } }

        protected Session.SerializerSessionPool SessionPool { get { throw null; } }

        protected abstract TValue[] TestValues { get; }

        protected virtual System.Action<System.Action<TValue>> ValueProvider { get { throw null; } }

        [Xunit.Fact]
        public void CanRoundTripCollectionViaSerializer() { }

        [Xunit.Fact]
        public void CanRoundTripDefaultValueViaCodec() { }

        [Xunit.Fact]
        public void CanRoundTripTupleViaSerializer() { }

        [Xunit.Fact]
        public void CanRoundTripViaObjectSerializer() { }

        [Xunit.Fact]
        public void CanRoundTripViaSerializer() { }

        [Xunit.Fact]
        public void CanRoundTripViaSerializer_Array() { }

        [Xunit.Fact]
        public void CanRoundTripViaSerializer_Memory() { }

        [Xunit.Fact]
        public void CanRoundTripViaSerializer_MemoryStream() { }

        [Xunit.Fact]
        public void CanRoundTripViaSerializer_ReadByteByByte() { }

        [Xunit.Fact]
        public void CanRoundTripViaSerializer_Span() { }

        [Xunit.Fact]
        public void CanRoundTripViaSerializer_StreamPooled() { }

        [Xunit.Fact]
        public void CanRoundTripWeaklyTypedCollectionViaSerializer() { }

        [Xunit.Fact]
        public void CanSkipDefaultValue() { }

        [Xunit.Fact]
        public void CanSkipValue() { }

        protected virtual void Configure(ISerializerBuilder builder) { }

        [Xunit.Fact]
        public void CorrectlyAdvancesReferenceCounter() { }

        [Xunit.Fact]
        public void CorrectlyAdvancesReferenceCounterStream() { }

        [Xunit.Fact]
        public void CorrectlyHandlesBuffers() { }

        protected virtual TCodec CreateCodec() { throw null; }

        protected abstract TValue CreateValue();
        protected virtual bool Equals(TValue left, TValue right) { throw null; }

        protected virtual TValue GetWriteCopy(TValue input) { throw null; }

        [Xunit.Fact]
        public void ProducesValidBitStream() { }

        [Xunit.Fact]
        public void RoundTrippedValuesEqual() { }

        protected T RoundTripThroughCodec<T>(T original) { throw null; }

        protected object RoundTripThroughUntypedSerializer(object original, out string formattedBitStream) { throw null; }

        void System.IDisposable.Dispose() { }

        [Xunit.Fact]
        public void WritersProduceSameResults() { }
    }

    public partial interface IOutputBuffer
    {
        System.Buffers.ReadOnlySequence<byte> GetReadOnlySequence(int maxSegmentSize);
    }

    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public static partial class ReadOnlySequenceHelper
    {
        public static System.Collections.Generic.IEnumerable<byte[]> Batch(this System.Collections.Generic.IEnumerable<byte> sequence, int batchSize) { throw null; }

        public static System.Buffers.ReadOnlySequence<byte> CreateReadOnlySequence(params byte[][] buffers) { throw null; }

        public static System.Buffers.ReadOnlySequence<byte> ToReadOnlySequence(this System.Collections.Generic.IEnumerable<byte[]> buffers) { throw null; }

        public static System.Buffers.ReadOnlySequence<byte> ToReadOnlySequence(this System.Collections.Generic.IEnumerable<System.Memory<byte>> buffers) { throw null; }
    }

    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public partial struct TestBufferWriterStruct : System.Buffers.IBufferWriter<byte>, IOutputBuffer
    {
        private object _dummy;
        private int _dummyPrimitive;
        public TestBufferWriterStruct(byte[] buffer) { }

        public void Advance(int bytes) { }

        public readonly System.Memory<byte> GetMemory(int sizeHint = 0) { throw null; }

        public readonly System.Buffers.ReadOnlySequence<byte> GetReadOnlySequence(int maxSegmentSize) { throw null; }

        public readonly System.Span<byte> GetSpan(int sizeHint) { throw null; }
    }

    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public partial class TestMultiSegmentBufferWriter : System.Buffers.IBufferWriter<byte>, IOutputBuffer
    {
        public TestMultiSegmentBufferWriter(int maxAllocationSize) { }

        public void Advance(int bytes) { }

        public System.Memory<byte> GetMemory(int sizeHint = 0) { throw null; }

        public System.Buffers.ReadOnlySequence<byte> GetReadOnlySequence(int maxSegmentSize) { throw null; }

        public System.Span<byte> GetSpan(int sizeHint) { throw null; }

        public System.Buffers.ReadOnlySequence<byte> PeekAllBuffers() { throw null; }
    }

    public abstract partial class ValueTypeFieldCodecTester<TField, TCodec> : FieldCodecTester<TField, TCodec> where TField : struct where TCodec : class, Codecs.IFieldCodec<TField>
    {
        protected ValueTypeFieldCodecTester(Xunit.Abstractions.ITestOutputHelper output) : base(default!) { }

        [Xunit.Fact]
        public void DirectAccessValueSerializerRoundTrip() { }

        [Xunit.Fact]
        public void ValueSerializerRoundTrip() { }
    }
}