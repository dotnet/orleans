//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Orleans.Configuration
{
    public partial class AzureTableStreamCheckpointerOptions : Streaming.EventHubs.AzureStorageOperationOptions
    {
        public static readonly System.TimeSpan DEFAULT_CHECKPOINT_PERSIST_INTERVAL;
        public const string DEFAULT_TABLE_NAME = "Checkpoint";
        public System.TimeSpan PersistInterval { get { throw null; } set { } }

        public override string TableName { get { throw null; } set { } }
    }

    public partial class AzureTableStreamCheckpointerOptionsValidator : Streaming.EventHubs.AzureStorageOperationOptionsValidator<AzureTableStreamCheckpointerOptions>
    {
        public AzureTableStreamCheckpointerOptionsValidator(AzureTableStreamCheckpointerOptions options, string name) : base(default!, default!) { }
    }

    public partial class EventDataGeneratorStreamOptions
    {
        public const int DefaultEventHubPartitionCount = 4;
        public int EventHubPartitionCount;
    }

    public partial class EventHubOptions
    {
        public Azure.Messaging.EventHubs.EventHubConnectionOptions ConnectionOptions { get { throw null; } set { } }

        public void ConfigureEventHubConnection(Azure.Messaging.EventHubs.EventHubConnection connection, string consumerGroup) { }

        public void ConfigureEventHubConnection(CreateConnectionDelegate createConnection, string eventHubName, string consumerGroup) { }

        public void ConfigureEventHubConnection(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, Azure.AzureNamedKeyCredential credential) { }

        public void ConfigureEventHubConnection(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, Azure.AzureSasCredential credential) { }

        public void ConfigureEventHubConnection(string fullyQualifiedNamespace, string eventHubName, string consumerGroup, Azure.Core.TokenCredential credential) { }

        public void ConfigureEventHubConnection(string connectionString, string eventHubName, string consumerGroup) { }

        public delegate Azure.Messaging.EventHubs.EventHubConnection CreateConnectionDelegate(Azure.Messaging.EventHubs.EventHubConnectionOptions connectionOptions);
    }

    public partial class EventHubOptionsValidator : IConfigurationValidator
    {
        public EventHubOptionsValidator(EventHubOptions options, string name) { }

        public void ValidateConfiguration() { }
    }

    public partial class EventHubReceiverOptions
    {
        public int? PrefetchCount { get { throw null; } set { } }

        public bool StartFromNow { get { throw null; } set { } }
    }

    public partial class EventHubStreamCachePressureOptions
    {
        public double? AveragingCachePressureMonitorFlowControlThreshold { get { throw null; } set { } }

        public double? SlowConsumingMonitorFlowControlThreshold { get { throw null; } set { } }

        public System.TimeSpan? SlowConsumingMonitorPressureWindowSize { get { throw null; } set { } }
    }

    public partial class StreamCheckpointerConfigurationValidator : IConfigurationValidator
    {
        public StreamCheckpointerConfigurationValidator(System.IServiceProvider services, string name) { }

        public void ValidateConfiguration() { }
    }
}

namespace Orleans.Hosting
{
    public static partial class ClientBuilderExtensions
    {
        public static IClientBuilder AddEventHubStreams(this IClientBuilder builder, string name, System.Action<Configuration.EventHubOptions> configureEventHub) { throw null; }

        public static IClientBuilder AddEventHubStreams(this IClientBuilder builder, string name, System.Action<IClusterClientEventHubStreamConfigurator> configure) { throw null; }
    }

    public partial class ClusterClientEventHubStreamConfigurator : ClusterClientPersistentStreamConfigurator, IClusterClientEventHubStreamConfigurator, IEventHubStreamConfigurator, INamedServiceConfigurator, IClusterClientPersistentStreamConfigurator, IPersistentStreamConfigurator
    {
        public ClusterClientEventHubStreamConfigurator(string name, IClientBuilder builder) : base(default!, default!, default!) { }
    }

    public static partial class EventHubStreamConfiguratorExtensions
    {
        public static void ConfigureEventHub(this IEventHubStreamConfigurator configurator, System.Action<Microsoft.Extensions.Options.OptionsBuilder<Configuration.EventHubOptions>> configureOptions) { }

        public static void UseDataAdapter(this IEventHubStreamConfigurator configurator, System.Func<System.IServiceProvider, string, Streaming.EventHubs.IEventHubDataAdapter> factory) { }
    }

    public partial interface IClusterClientEventHubStreamConfigurator : IEventHubStreamConfigurator, INamedServiceConfigurator, IClusterClientPersistentStreamConfigurator, IPersistentStreamConfigurator
    {
    }

    public partial interface IEventHubStreamConfigurator : INamedServiceConfigurator
    {
    }

    public partial interface ISiloEventHubStreamConfigurator : IEventHubStreamConfigurator, INamedServiceConfigurator, ISiloRecoverableStreamConfigurator, ISiloPersistentStreamConfigurator, IPersistentStreamConfigurator
    {
    }

    public static partial class SiloBuilderExtensions
    {
        public static ISiloBuilder AddEventHubStreams(this ISiloBuilder builder, string name, System.Action<Configuration.EventHubOptions> configureEventHub, System.Action<Configuration.AzureTableStreamCheckpointerOptions> configureDefaultCheckpointer) { throw null; }

        public static ISiloBuilder AddEventHubStreams(this ISiloBuilder builder, string name, System.Action<ISiloEventHubStreamConfigurator> configure) { throw null; }
    }

    public partial class SiloEventHubStreamConfigurator : SiloRecoverableStreamConfigurator, ISiloEventHubStreamConfigurator, IEventHubStreamConfigurator, INamedServiceConfigurator, ISiloRecoverableStreamConfigurator, ISiloPersistentStreamConfigurator, IPersistentStreamConfigurator
    {
        public SiloEventHubStreamConfigurator(string name, System.Action<System.Action<Microsoft.Extensions.DependencyInjection.IServiceCollection>> configureServicesDelegate) : base(default!, default!, default!) { }
    }

    public static partial class SiloEventHubStreamConfiguratorExtensions
    {
        public static void ConfigureCachePressuring(this ISiloEventHubStreamConfigurator configurator, System.Action<Microsoft.Extensions.Options.OptionsBuilder<Configuration.EventHubStreamCachePressureOptions>> configureOptions) { }

        public static void ConfigureCheckpointer<TOptions>(this ISiloEventHubStreamConfigurator configurator, System.Func<System.IServiceProvider, string, Streams.IStreamQueueCheckpointerFactory> checkpointerFactoryBuilder, System.Action<Microsoft.Extensions.Options.OptionsBuilder<TOptions>> configureOptions)
            where TOptions : class, new() { }

        public static void ConfigurePartitionReceiver(this ISiloEventHubStreamConfigurator configurator, System.Action<Microsoft.Extensions.Options.OptionsBuilder<Configuration.EventHubReceiverOptions>> configureOptions) { }

        public static void UseAzureTableCheckpointer(this ISiloEventHubStreamConfigurator configurator, System.Action<Microsoft.Extensions.Options.OptionsBuilder<Configuration.AzureTableStreamCheckpointerOptions>> configureOptions) { }
    }
}

namespace Orleans.Hosting.Developer
{
    public static partial class EventDataGeneratorConfiguratorExtensions
    {
        public static void ConfigureCachePressuring(this IEventDataGeneratorStreamConfigurator configurator, System.Action<Microsoft.Extensions.Options.OptionsBuilder<Configuration.EventHubStreamCachePressureOptions>> configureOptions) { }

        public static void UseDataAdapter(this IEventDataGeneratorStreamConfigurator configurator, System.Func<System.IServiceProvider, string, Streaming.EventHubs.IEventHubDataAdapter> factory) { }
    }

    public partial class EventDataGeneratorStreamConfigurator : SiloRecoverableStreamConfigurator, IEventDataGeneratorStreamConfigurator, ISiloRecoverableStreamConfigurator, ISiloPersistentStreamConfigurator, IPersistentStreamConfigurator, INamedServiceConfigurator
    {
        public EventDataGeneratorStreamConfigurator(string name, System.Action<System.Action<Microsoft.Extensions.DependencyInjection.IServiceCollection>> configureServicesDelegate) : base(default!, default!, default!) { }
    }

    public partial interface IEventDataGeneratorStreamConfigurator : ISiloRecoverableStreamConfigurator, ISiloPersistentStreamConfigurator, IPersistentStreamConfigurator, INamedServiceConfigurator
    {
    }

    public static partial class SiloBuilderExtensions
    {
        public static ISiloBuilder AddEventDataGeneratorStreams(this ISiloBuilder builder, string name, System.Action<IEventDataGeneratorStreamConfigurator> configure) { throw null; }
    }
}

namespace Orleans.Streaming.EventHubs
{
    public partial class AggregatedCachePressureMonitor : System.Collections.Generic.List<ICachePressureMonitor>, ICachePressureMonitor
    {
        public AggregatedCachePressureMonitor(Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor monitor = null) { }

        public Providers.Streams.Common.ICacheMonitor CacheMonitor { set { } }

        public void AddCachePressureMonitor(ICachePressureMonitor monitor) { }

        public bool IsUnderPressure(System.DateTime utcNow) { throw null; }

        public void RecordCachePressureContribution(double cachePressureContribution) { }
    }

    public partial class AveragingCachePressureMonitor : ICachePressureMonitor
    {
        public AveragingCachePressureMonitor(Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor monitor = null) { }

        public AveragingCachePressureMonitor(double flowControlThreshold, Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor monitor = null) { }

        public Providers.Streams.Common.ICacheMonitor CacheMonitor { set { } }

        public bool IsUnderPressure(System.DateTime utcNow) { throw null; }

        public void RecordCachePressureContribution(double cachePressureContribution) { }
    }

    public partial class AzureStorageOperationOptions
    {
        public Azure.Data.Tables.TableClientOptions ClientOptions { get { throw null; } set { } }

        public AzureStoragePolicyOptions StoragePolicyOptions { get { throw null; } }

        public virtual string TableName { get { throw null; } set { } }

        public Azure.Data.Tables.TableServiceClient TableServiceClient { get { throw null; } set { } }

        [System.Obsolete("Set the TableServiceClient property directly.")]
        public void ConfigureTableServiceClient(System.Func<System.Threading.Tasks.Task<Azure.Data.Tables.TableServiceClient>> createClientCallback) { }

        [System.Obsolete("Set the TableServiceClient property directly.")]
        public void ConfigureTableServiceClient(string connectionString) { }

        [System.Obsolete("Set the TableServiceClient property directly.")]
        public void ConfigureTableServiceClient(System.Uri serviceUri, Azure.AzureSasCredential azureSasCredential) { }

        [System.Obsolete("Set the TableServiceClient property directly.")]
        public void ConfigureTableServiceClient(System.Uri serviceUri, Azure.Core.TokenCredential tokenCredential) { }

        [System.Obsolete("Set the TableServiceClient property directly.")]
        public void ConfigureTableServiceClient(System.Uri serviceUri, Azure.Data.Tables.TableSharedKeyCredential sharedKeyCredential) { }

        [System.Obsolete("Set the TableServiceClient property directly.")]
        public void ConfigureTableServiceClient(System.Uri serviceUri) { }
    }

    public partial class AzureStorageOperationOptionsValidator<TOptions> : IConfigurationValidator where TOptions : AzureStorageOperationOptions
    {
        public AzureStorageOperationOptionsValidator(TOptions options, string name = null) { }

        public string Name { get { throw null; } }

        public TOptions Options { get { throw null; } }

        public virtual void ValidateConfiguration() { }
    }

    public partial class AzureStoragePolicyOptions
    {
        public System.TimeSpan CreationTimeout { get { throw null; } set { } }

        public int MaxBulkUpdateRows { get { throw null; } set { } }

        public int MaxCreationRetries { get { throw null; } set { } }

        public int MaxOperationRetries { get { throw null; } set { } }

        public System.TimeSpan OperationTimeout { get { throw null; } set { } }

        public System.TimeSpan PauseBetweenCreationRetries { get { throw null; } set { } }

        public System.TimeSpan PauseBetweenOperationRetries { get { throw null; } set { } }
    }

    public partial class DefaultEventHubReceiverMonitor : Providers.Streams.Common.DefaultQueueAdapterReceiverMonitor
    {
        public DefaultEventHubReceiverMonitor(EventHubReceiverMonitorDimensions dimensions) : base(default(System.Collections.Generic.KeyValuePair<string, object>[])!) { }
    }

    public static partial class EventDataExtensions
    {
        public static System.Collections.Generic.IDictionary<string, object> DeserializeProperties(this System.ArraySegment<byte> bytes, Serialization.Serializer serializer) { throw null; }

        public static string GetStreamNamespaceProperty(this Azure.Messaging.EventHubs.EventData eventData) { throw null; }

        public static byte[] SerializeProperties(this Azure.Messaging.EventHubs.EventData eventData, Serialization.Serializer serializer) { throw null; }

        public static void SetStreamNamespaceProperty(this Azure.Messaging.EventHubs.EventData eventData, string streamNamespace) { }
    }

    public partial class EventHubAdapterFactory : Streams.IQueueAdapterFactory, Streams.IQueueAdapter, Streams.IQueueAdapterCache
    {
        protected readonly IEventHubDataAdapter dataAdapter;
        protected System.Func<EventHubPartitionSettings, string, Microsoft.Extensions.Logging.ILogger, IEventHubReceiver> EventHubReceiverFactory;
        protected Microsoft.Extensions.Logging.ILogger logger;
        protected readonly System.IServiceProvider serviceProvider;
        public EventHubAdapterFactory(string name, Configuration.EventHubOptions ehOptions, Configuration.EventHubReceiverOptions receiverOptions, Configuration.EventHubStreamCachePressureOptions cacheOptions, Configuration.StreamCacheEvictionOptions cacheEvictionOptions, Configuration.StreamStatisticOptions statisticOptions, IEventHubDataAdapter dataAdapter, System.IServiceProvider serviceProvider, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory, Statistics.IEnvironmentStatisticsProvider environmentStatisticsProvider) { }

        protected System.Func<string, Streams.IStreamQueueCheckpointer<string>, Microsoft.Extensions.Logging.ILoggerFactory, IEventHubQueueCache> CacheFactory { get { throw null; } set { } }

        public Streams.StreamProviderDirection Direction { get { throw null; } protected set { } }

        public bool IsRewindable { get { throw null; } }

        public string Name { get { throw null; } }

        protected System.Func<string[], Streams.HashRingBasedPartitionedStreamQueueMapper> QueueMapperFactory { get { throw null; } set { } }

        protected System.Func<EventHubReceiverMonitorDimensions, Microsoft.Extensions.Logging.ILoggerFactory, Providers.Streams.Common.IQueueAdapterReceiverMonitor> ReceiverMonitorFactory { get { throw null; } set { } }

        protected System.Func<string, System.Threading.Tasks.Task<Streams.IStreamFailureHandler>> StreamFailureHandlerFactory { get { throw null; } set { } }

        public static EventHubAdapterFactory Create(System.IServiceProvider services, string name) { throw null; }

        public System.Threading.Tasks.Task<Streams.IQueueAdapter> CreateAdapter() { throw null; }

        protected virtual IEventHubQueueCacheFactory CreateCacheFactory(Configuration.EventHubStreamCachePressureOptions eventHubCacheOptions) { throw null; }

        public Streams.IQueueCache CreateQueueCache(Streams.QueueId queueId) { throw null; }

        public Streams.IQueueAdapterReceiver CreateReceiver(Streams.QueueId queueId) { throw null; }

        public System.Threading.Tasks.Task<Streams.IStreamFailureHandler> GetDeliveryFailureHandler(Streams.QueueId queueId) { throw null; }

        protected virtual System.Threading.Tasks.Task<string[]> GetPartitionIdsAsync() { throw null; }

        public Streams.IQueueAdapterCache GetQueueAdapterCache() { throw null; }

        public Streams.IStreamQueueMapper GetStreamQueueMapper() { throw null; }

        public virtual void Init() { }

        protected virtual void InitEventHubClient() { }

        public virtual System.Threading.Tasks.Task QueueMessageBatchAsync<T>(Runtime.StreamId streamId, System.Collections.Generic.IEnumerable<T> events, Streams.StreamSequenceToken token, System.Collections.Generic.Dictionary<string, object> requestContext) { throw null; }
    }

    [GenerateSerializer]
    public partial class EventHubBatchContainer : Streams.IBatchContainer
    {
        public EventHubBatchContainer(EventHubMessage eventHubMessage, Serialization.Serializer serializer) { }

        public Streams.StreamSequenceToken SequenceToken { get { throw null; } }

        public Runtime.StreamId StreamId { get { throw null; } }

        public System.Collections.Generic.IEnumerable<System.Tuple<T, Streams.StreamSequenceToken>> GetEvents<T>() { throw null; }

        public bool ImportRequestContext() { throw null; }

        public static Azure.Messaging.EventHubs.EventData ToEventData<T>(Serialization.Serializer bodySerializer, Runtime.StreamId streamId, System.Collections.Generic.IEnumerable<T> events, System.Collections.Generic.Dictionary<string, object> requestContext) { throw null; }
    }

    public partial class EventHubBlockPoolMonitorDimensions : EventHubMonitorAggregationDimensions
    {
        public EventHubBlockPoolMonitorDimensions() { }

        public EventHubBlockPoolMonitorDimensions(EventHubMonitorAggregationDimensions dimensions, string blockPoolId) { }

        public string BlockPoolId { get { throw null; } set { } }
    }

    public partial class EventHubCacheMonitorDimensions : EventHubReceiverMonitorDimensions
    {
        public EventHubCacheMonitorDimensions() { }

        public EventHubCacheMonitorDimensions(EventHubMonitorAggregationDimensions dimensions, string ehPartition, string blockPoolId) { }

        public string BlockPoolId { get { throw null; } set { } }
    }

    public partial class EventHubCheckpointer : Streams.IStreamQueueCheckpointer<string>
    {
        internal EventHubCheckpointer() { }

        public bool CheckpointExists { get { throw null; } }

        public static System.Threading.Tasks.Task<Streams.IStreamQueueCheckpointer<string>> Create(Configuration.AzureTableStreamCheckpointerOptions options, string streamProviderName, string partition, string serviceId, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory) { throw null; }

        public System.Threading.Tasks.Task<string> Load() { throw null; }

        public void Update(string offset, System.DateTime utcNow) { }
    }

    public partial class EventHubCheckpointerFactory : Streams.IStreamQueueCheckpointerFactory
    {
        public EventHubCheckpointerFactory(string providerName, Configuration.AzureTableStreamCheckpointerOptions options, Microsoft.Extensions.Options.IOptions<Configuration.ClusterOptions> clusterOptions, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory) { }

        public System.Threading.Tasks.Task<Streams.IStreamQueueCheckpointer<string>> Create(string partition) { throw null; }

        public static Streams.IStreamQueueCheckpointerFactory CreateFactory(System.IServiceProvider services, string providerName) { throw null; }
    }

    public partial class EventHubDataAdapter : IEventHubDataAdapter, Streams.IQueueDataAdapter<Azure.Messaging.EventHubs.EventData>, Providers.Streams.Common.ICacheDataAdapter
    {
        public EventHubDataAdapter(Serialization.Serializer serializer) { }

        protected virtual System.ArraySegment<byte> EncodeMessageIntoSegment(Azure.Messaging.EventHubs.EventData queueMessage, System.Func<int, System.ArraySegment<byte>> getSegment) { throw null; }

        public virtual Providers.Streams.Common.CachedMessage FromQueueMessage(Streams.StreamPosition streamPosition, Azure.Messaging.EventHubs.EventData queueMessage, System.DateTime dequeueTime, System.Func<int, System.ArraySegment<byte>> getSegment) { throw null; }

        public virtual Streams.IBatchContainer GetBatchContainer(ref Providers.Streams.Common.CachedMessage cachedMessage) { throw null; }

        protected virtual Streams.IBatchContainer GetBatchContainer(EventHubMessage eventHubMessage) { throw null; }

        public virtual string GetOffset(Providers.Streams.Common.CachedMessage lastItemPurged) { throw null; }

        public virtual string GetPartitionKey(Runtime.StreamId streamId) { throw null; }

        public virtual Streams.StreamSequenceToken GetSequenceToken(ref Providers.Streams.Common.CachedMessage cachedMessage) { throw null; }

        public virtual Runtime.StreamId GetStreamIdentity(Azure.Messaging.EventHubs.EventData queueMessage) { throw null; }

        public virtual Streams.StreamPosition GetStreamPosition(string partition, Azure.Messaging.EventHubs.EventData queueMessage) { throw null; }

        public virtual Azure.Messaging.EventHubs.EventData ToQueueMessage<T>(Runtime.StreamId streamId, System.Collections.Generic.IEnumerable<T> events, Streams.StreamSequenceToken token, System.Collections.Generic.Dictionary<string, object> requestContext) { throw null; }
    }

    [GenerateSerializer]
    public partial class EventHubMessage
    {
        public EventHubMessage(Providers.Streams.Common.CachedMessage cachedMessage, Serialization.Serializer serializer) { }

        public EventHubMessage(Runtime.StreamId streamId, string partitionKey, string offset, long sequenceNumber, System.DateTime enqueueTimeUtc, System.DateTime dequeueTimeUtc, System.Collections.Generic.IDictionary<string, object> properties, byte[] payload) { }

        [Id(5)]
        public System.DateTime DequeueTimeUtc { get { throw null; } }

        [Id(4)]
        public System.DateTime EnqueueTimeUtc { get { throw null; } }

        [Id(2)]
        public string Offset { get { throw null; } }

        [Id(1)]
        public string PartitionKey { get { throw null; } }

        [Id(7)]
        public byte[] Payload { get { throw null; } }

        [Id(6)]
        public System.Collections.Generic.IDictionary<string, object> Properties { get { throw null; } }

        [Id(3)]
        public long SequenceNumber { get { throw null; } }

        [Id(0)]
        public Runtime.StreamId StreamId { get { throw null; } }
    }

    public partial class EventHubMonitorAggregationDimensions
    {
        public EventHubMonitorAggregationDimensions() { }

        public EventHubMonitorAggregationDimensions(EventHubMonitorAggregationDimensions dimensions) { }

        public EventHubMonitorAggregationDimensions(string ehHubPath) { }

        public string EventHubPath { get { throw null; } set { } }
    }

    public partial class EventHubPartitionSettings
    {
        public Configuration.EventHubOptions Hub { get { throw null; } set { } }

        public string Partition { get { throw null; } set { } }

        public Configuration.EventHubReceiverOptions ReceiverOptions { get { throw null; } set { } }
    }

    public partial class EventHubQueueCache : IEventHubQueueCache, Streams.IQueueFlowController, System.IDisposable
    {
        protected readonly Providers.Streams.Common.PooledQueueCache cache;
        public EventHubQueueCache(string partition, int defaultMaxAddCount, Providers.Streams.Common.IObjectPool<Providers.Streams.Common.FixedSizeBuffer> bufferPool, IEventHubDataAdapter dataAdapter, Providers.Streams.Common.IEvictionStrategy evictionStrategy, Streams.IStreamQueueCheckpointer<string> checkpointer, Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor cacheMonitor, System.TimeSpan? cacheMonitorWriteInterval, System.TimeSpan? metadataMinTimeInCache) { }

        public string Partition { get { throw null; } }

        public System.Collections.Generic.List<Streams.StreamPosition> Add(System.Collections.Generic.List<Azure.Messaging.EventHubs.EventData> messages, System.DateTime dequeueTimeUtc) { throw null; }

        public void AddCachePressureMonitor(ICachePressureMonitor monitor) { }

        public void Dispose() { }

        public object GetCursor(Runtime.StreamId streamId, Streams.StreamSequenceToken sequenceToken) { throw null; }

        public int GetMaxAddCount() { throw null; }

        public void SignalPurge() { }

        public bool TryGetNextMessage(object cursorObj, out Streams.IBatchContainer message) { throw null; }
    }

    public partial class EventHubQueueCacheFactory : IEventHubQueueCacheFactory
    {
        public EventHubQueueCacheFactory(Configuration.EventHubStreamCachePressureOptions cacheOptions, Configuration.StreamCacheEvictionOptions evictionOptions, Configuration.StreamStatisticOptions statisticOptions, IEventHubDataAdapter dataAdater, EventHubMonitorAggregationDimensions sharedDimensions, System.Func<EventHubCacheMonitorDimensions, Microsoft.Extensions.Logging.ILoggerFactory, Providers.Streams.Common.ICacheMonitor> cacheMonitorFactory = null, System.Func<EventHubBlockPoolMonitorDimensions, Microsoft.Extensions.Logging.ILoggerFactory, Providers.Streams.Common.IBlockPoolMonitor> blockPoolMonitorFactory = null) { }

        public System.Func<EventHubBlockPoolMonitorDimensions, Microsoft.Extensions.Logging.ILoggerFactory, Providers.Streams.Common.IBlockPoolMonitor> BlockPoolMonitorFactory { get { throw null; } set { } }

        public System.Func<EventHubCacheMonitorDimensions, Microsoft.Extensions.Logging.ILoggerFactory, Providers.Streams.Common.ICacheMonitor> CacheMonitorFactory { get { throw null; } set { } }

        protected virtual void AddCachePressureMonitors(IEventHubQueueCache cache, Configuration.EventHubStreamCachePressureOptions providerOptions, Microsoft.Extensions.Logging.ILogger cacheLogger) { }

        protected virtual Providers.Streams.Common.IObjectPool<Providers.Streams.Common.FixedSizeBuffer> CreateBufferPool(Configuration.StreamStatisticOptions statisticOptions, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory, EventHubMonitorAggregationDimensions sharedDimensions, out string blockPoolId) { throw null; }

        protected virtual IEventHubQueueCache CreateCache(string partition, IEventHubDataAdapter dataAdatper, Configuration.StreamStatisticOptions statisticOptions, Configuration.StreamCacheEvictionOptions streamCacheEvictionOptions, Streams.IStreamQueueCheckpointer<string> checkpointer, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory, Providers.Streams.Common.IObjectPool<Providers.Streams.Common.FixedSizeBuffer> bufferPool, string blockPoolId, Providers.Streams.Common.TimePurgePredicate timePurge, EventHubMonitorAggregationDimensions sharedDimensions) { throw null; }

        public IEventHubQueueCache CreateCache(string partition, Streams.IStreamQueueCheckpointer<string> checkpointer, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory) { throw null; }
    }

    public partial class EventHubReceiverMonitorDimensions : EventHubMonitorAggregationDimensions
    {
        public EventHubReceiverMonitorDimensions() { }

        public EventHubReceiverMonitorDimensions(EventHubMonitorAggregationDimensions dimensions, string ehPartition) { }

        public string EventHubPartition { get { throw null; } set { } }
    }

    [GenerateSerializer]
    public partial class EventHubSequenceToken : Providers.Streams.Common.EventSequenceToken, IEventHubPartitionLocation
    {
        public EventHubSequenceToken() { }

        public EventHubSequenceToken(string eventHubOffset, long sequenceNumber, int eventIndex) { }

        [Id(0)]
        [Newtonsoft.Json.JsonProperty]
        public string EventHubOffset { get { throw null; } }

        public override string ToString() { throw null; }
    }

    [GenerateSerializer]
    public partial class EventHubSequenceTokenV2 : EventHubSequenceToken
    {
        public EventHubSequenceTokenV2() { }

        public EventHubSequenceTokenV2(string eventHubOffset, long sequenceNumber, int eventIndex) { }
    }

    public partial interface ICachePressureMonitor
    {
        Providers.Streams.Common.ICacheMonitor CacheMonitor { set; }

        bool IsUnderPressure(System.DateTime utcNow);
        void RecordCachePressureContribution(double cachePressureContribution);
    }

    public partial interface IEventHubDataAdapter : Streams.IQueueDataAdapter<Azure.Messaging.EventHubs.EventData>, Providers.Streams.Common.ICacheDataAdapter
    {
        Providers.Streams.Common.CachedMessage FromQueueMessage(Streams.StreamPosition position, Azure.Messaging.EventHubs.EventData queueMessage, System.DateTime dequeueTime, System.Func<int, System.ArraySegment<byte>> getSegment);
        string GetOffset(Providers.Streams.Common.CachedMessage cachedMessage);
        string GetPartitionKey(Runtime.StreamId streamId);
        Runtime.StreamId GetStreamIdentity(Azure.Messaging.EventHubs.EventData queueMessage);
        Streams.StreamPosition GetStreamPosition(string partition, Azure.Messaging.EventHubs.EventData queueMessage);
    }

    public partial interface IEventHubPartitionLocation
    {
        string EventHubOffset { get; }

        long SequenceNumber { get; }
    }

    public partial interface IEventHubQueueCache : Streams.IQueueFlowController, System.IDisposable
    {
        System.Collections.Generic.List<Streams.StreamPosition> Add(System.Collections.Generic.List<Azure.Messaging.EventHubs.EventData> message, System.DateTime dequeueTimeUtc);
        void AddCachePressureMonitor(ICachePressureMonitor monitor);
        object GetCursor(Runtime.StreamId streamId, Streams.StreamSequenceToken sequenceToken);
        void SignalPurge();
        bool TryGetNextMessage(object cursorObj, out Streams.IBatchContainer message);
    }

    public partial interface IEventHubQueueCacheFactory
    {
        IEventHubQueueCache CreateCache(string partition, Streams.IStreamQueueCheckpointer<string> checkpointer, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory);
    }

    public partial interface IEventHubReceiver
    {
        System.Threading.Tasks.Task CloseAsync();
        System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Azure.Messaging.EventHubs.EventData>> ReceiveAsync(int maxCount, System.TimeSpan waitTime);
    }

    public partial class SlowConsumingPressureMonitor : ICachePressureMonitor
    {
        public const double DefaultFlowControlThreshold = 0.5D;
        public static System.TimeSpan DefaultPressureWindowSize;
        public SlowConsumingPressureMonitor(Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor monitor = null) { }

        public SlowConsumingPressureMonitor(double flowControlThreshold, Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor monitor = null) { }

        public SlowConsumingPressureMonitor(double flowControlThreshold, System.TimeSpan pressureWindowSzie, Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor monitor = null) { }

        public SlowConsumingPressureMonitor(System.TimeSpan pressureWindowSize, Microsoft.Extensions.Logging.ILogger logger, Providers.Streams.Common.ICacheMonitor monitor = null) { }

        public Providers.Streams.Common.ICacheMonitor CacheMonitor { set { } }

        public double FlowControlThreshold { get { throw null; } set { } }

        public System.TimeSpan PressureWindowSize { get { throw null; } set { } }

        public bool IsUnderPressure(System.DateTime utcNow) { throw null; }

        public void RecordCachePressureContribution(double cachePressureContribution) { }
    }
}

namespace Orleans.Streaming.EventHubs.StatisticMonitors
{
    public partial class DefaultEventHubBlockPoolMonitor : Providers.Streams.Common.DefaultBlockPoolMonitor
    {
        public DefaultEventHubBlockPoolMonitor(EventHubBlockPoolMonitorDimensions dimensions) : base(default(System.Collections.Generic.KeyValuePair<string, object>[])!) { }
    }

    public partial class DefaultEventHubCacheMonitor : Providers.Streams.Common.DefaultCacheMonitor
    {
        public DefaultEventHubCacheMonitor(EventHubCacheMonitorDimensions dimensions) : base(default(System.Collections.Generic.KeyValuePair<string, object>[])!) { }
    }
}

namespace Orleans.Streaming.EventHubs.Testing
{
    public partial class EventDataGeneratorAdapterFactory : EventHubAdapterFactory, Providers.IControllable
    {
        public EventDataGeneratorAdapterFactory(string name, Configuration.EventDataGeneratorStreamOptions options, Configuration.EventHubOptions ehOptions, Configuration.EventHubReceiverOptions receiverOptions, Configuration.EventHubStreamCachePressureOptions cacheOptions, Configuration.StreamCacheEvictionOptions evictionOptions, Configuration.StreamStatisticOptions statisticOptions, IEventHubDataAdapter dataAdapter, System.IServiceProvider serviceProvider, Microsoft.Extensions.Logging.ILoggerFactory loggerFactory, Statistics.IEnvironmentStatisticsProvider environmentStatisticsProvider) : base(default!, default!, default!, default!, default!, default!, default!, default!, default!, default!) { }

        public new static EventDataGeneratorAdapterFactory Create(System.IServiceProvider services, string name) { throw null; }

        public virtual System.Threading.Tasks.Task<object> ExecuteCommand(int command, object arg) { throw null; }

        public static string[] GenerateEventHubPartitions(int partitionCount) { throw null; }

        protected override System.Threading.Tasks.Task<string[]> GetPartitionIdsAsync() { throw null; }

        public override void Init() { }

        protected override void InitEventHubClient() { }

        public enum Commands
        {
            Randomly_Place_Stream_To_Queue = 20004,
            Stop_Producing_On_Stream = 20005
        }

        [GenerateSerializer]
        public partial class StreamRandomPlacementArg
        {
            public StreamRandomPlacementArg(Runtime.StreamId streamId, int randomNumber) { }

            [Id(1)]
            public int RandomNumber { get { throw null; } set { } }

            [Id(0)]
            public Runtime.StreamId StreamId { get { throw null; } set { } }
        }
    }

    public partial class EventHubPartitionDataGenerator : IDataGenerator<Azure.Messaging.EventHubs.EventData>, IStreamDataGeneratingController
    {
        public EventHubPartitionDataGenerator(Configuration.EventDataGeneratorStreamOptions options, System.Func<Runtime.StreamId, IStreamDataGenerator<Azure.Messaging.EventHubs.EventData>> generatorFactory, Microsoft.Extensions.Logging.ILogger logger) { }

        public void AddDataGeneratorForStream(Runtime.StreamId streamId) { }

        public void StopProducingOnStream(Runtime.StreamId streamId) { }

        public bool TryReadEvents(int maxCount, out System.Collections.Generic.IEnumerable<Azure.Messaging.EventHubs.EventData> events) { throw null; }
    }

    public partial class EventHubPartitionGeneratorReceiver : IEventHubReceiver
    {
        public EventHubPartitionGeneratorReceiver(IDataGenerator<Azure.Messaging.EventHubs.EventData> generator) { }

        public System.Threading.Tasks.Task CloseAsync() { throw null; }

        public void ConfigureDataGeneratorForStream(Runtime.StreamId streamId) { }

        public System.Threading.Tasks.Task<System.Collections.Generic.IEnumerable<Azure.Messaging.EventHubs.EventData>> ReceiveAsync(int maxCount, System.TimeSpan waitTime) { throw null; }

        public void StopProducingOnStream(Runtime.StreamId streamId) { }
    }

    public partial interface IDataGenerator<T>
    {
        bool TryReadEvents(int maxCount, out System.Collections.Generic.IEnumerable<T> events);
    }

    public partial interface IIntCounter
    {
        int Value { get; }

        void Increment();
    }

    public partial interface IStreamDataGeneratingController
    {
        void AddDataGeneratorForStream(Runtime.StreamId streamId);
        void StopProducingOnStream(Runtime.StreamId streamId);
    }

    public partial interface IStreamDataGenerator<T> : IDataGenerator<T>
    {
        IIntCounter SequenceNumberCounter { set; }

        bool ShouldProduce { set; }

        Runtime.StreamId StreamId { get; }
    }

    public partial class NoOpCheckpointer : Streams.IStreamQueueCheckpointer<string>
    {
        public static NoOpCheckpointer Instance;
        public bool CheckpointExists { get { throw null; } }

        public System.Threading.Tasks.Task<string> Load() { throw null; }

        public void Update(string offset, System.DateTime utcNow) { }
    }

    public partial class NoOpCheckpointerFactory : Streams.IStreamQueueCheckpointerFactory
    {
        public static NoOpCheckpointerFactory Instance;
        public System.Threading.Tasks.Task<Streams.IStreamQueueCheckpointer<string>> Create(string partition) { throw null; }
    }

    public partial class SimpleStreamEventDataGenerator : IStreamDataGenerator<Azure.Messaging.EventHubs.EventData>, IDataGenerator<Azure.Messaging.EventHubs.EventData>
    {
        public SimpleStreamEventDataGenerator(Runtime.StreamId streamId, Microsoft.Extensions.Logging.ILogger<SimpleStreamEventDataGenerator> logger, Serialization.DeepCopier deepCopier, Serialization.Serializer serializer) { }

        public IIntCounter SequenceNumberCounter { set { } }

        public bool ShouldProduce { set { } }

        public Runtime.StreamId StreamId { get { throw null; } set { } }

        public static System.Func<Runtime.StreamId, IStreamDataGenerator<Azure.Messaging.EventHubs.EventData>> CreateFactory(System.IServiceProvider services) { throw null; }

        public bool TryReadEvents(int maxCount, out System.Collections.Generic.IEnumerable<Azure.Messaging.EventHubs.EventData> events) { throw null; }
    }
}

namespace OrleansCodeGen.Orleans.Streaming.EventHubs
{
    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_EventHubBatchContainer : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.Streaming.EventHubs.EventHubBatchContainer>, global::Orleans.Serialization.Codecs.IFieldCodec, global::Orleans.Serialization.Serializers.IBaseCodec<global::Orleans.Streaming.EventHubs.EventHubBatchContainer>, global::Orleans.Serialization.Serializers.IBaseCodec
    {
        public Codec_EventHubBatchContainer(global::Orleans.Serialization.Activators.IActivator<global::Orleans.Streaming.EventHubs.EventHubBatchContainer> _activator, global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public void Deserialize<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Streaming.EventHubs.EventHubBatchContainer instance) { }

        public global::Orleans.Streaming.EventHubs.EventHubBatchContainer ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void Serialize<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, global::Orleans.Streaming.EventHubs.EventHubBatchContainer instance)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.Streaming.EventHubs.EventHubBatchContainer value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_EventHubMessage : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.Streaming.EventHubs.EventHubMessage>, global::Orleans.Serialization.Codecs.IFieldCodec, global::Orleans.Serialization.Serializers.IBaseCodec<global::Orleans.Streaming.EventHubs.EventHubMessage>, global::Orleans.Serialization.Serializers.IBaseCodec
    {
        public Codec_EventHubMessage(global::Orleans.Serialization.Activators.IActivator<global::Orleans.Streaming.EventHubs.EventHubMessage> _activator, global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public void Deserialize<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Streaming.EventHubs.EventHubMessage instance) { }

        public global::Orleans.Streaming.EventHubs.EventHubMessage ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void Serialize<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, global::Orleans.Streaming.EventHubs.EventHubMessage instance)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.Streaming.EventHubs.EventHubMessage value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_EventHubSequenceToken : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.Streaming.EventHubs.EventHubSequenceToken>, global::Orleans.Serialization.Codecs.IFieldCodec, global::Orleans.Serialization.Serializers.IBaseCodec<global::Orleans.Streaming.EventHubs.EventHubSequenceToken>, global::Orleans.Serialization.Serializers.IBaseCodec
    {
        public Codec_EventHubSequenceToken(global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public void Deserialize<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Streaming.EventHubs.EventHubSequenceToken instance) { }

        public global::Orleans.Streaming.EventHubs.EventHubSequenceToken ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void Serialize<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, global::Orleans.Streaming.EventHubs.EventHubSequenceToken instance)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.Streaming.EventHubs.EventHubSequenceToken value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_EventHubSequenceTokenV2 : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2>, global::Orleans.Serialization.Codecs.IFieldCodec, global::Orleans.Serialization.Serializers.IBaseCodec<global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2>, global::Orleans.Serialization.Serializers.IBaseCodec
    {
        public Codec_EventHubSequenceTokenV2(global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public void Deserialize<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 instance) { }

        public global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void Serialize<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 instance)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Copier_EventHubBatchContainer : global::Orleans.Serialization.Cloning.IDeepCopier<global::Orleans.Streaming.EventHubs.EventHubBatchContainer>, global::Orleans.Serialization.Cloning.IDeepCopier, global::Orleans.Serialization.Cloning.IBaseCopier<global::Orleans.Streaming.EventHubs.EventHubBatchContainer>, global::Orleans.Serialization.Cloning.IBaseCopier
    {
        public Copier_EventHubBatchContainer(global::Orleans.Serialization.Activators.IActivator<global::Orleans.Streaming.EventHubs.EventHubBatchContainer> _activator, global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public global::Orleans.Streaming.EventHubs.EventHubBatchContainer DeepCopy(global::Orleans.Streaming.EventHubs.EventHubBatchContainer original, global::Orleans.Serialization.Cloning.CopyContext context) { throw null; }

        public void DeepCopy(global::Orleans.Streaming.EventHubs.EventHubBatchContainer input, global::Orleans.Streaming.EventHubs.EventHubBatchContainer output, global::Orleans.Serialization.Cloning.CopyContext context) { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Copier_EventHubMessage : global::Orleans.Serialization.Cloning.IDeepCopier<global::Orleans.Streaming.EventHubs.EventHubMessage>, global::Orleans.Serialization.Cloning.IDeepCopier, global::Orleans.Serialization.Cloning.IBaseCopier<global::Orleans.Streaming.EventHubs.EventHubMessage>, global::Orleans.Serialization.Cloning.IBaseCopier
    {
        public Copier_EventHubMessage(global::Orleans.Serialization.Activators.IActivator<global::Orleans.Streaming.EventHubs.EventHubMessage> _activator, global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public global::Orleans.Streaming.EventHubs.EventHubMessage DeepCopy(global::Orleans.Streaming.EventHubs.EventHubMessage original, global::Orleans.Serialization.Cloning.CopyContext context) { throw null; }

        public void DeepCopy(global::Orleans.Streaming.EventHubs.EventHubMessage input, global::Orleans.Streaming.EventHubs.EventHubMessage output, global::Orleans.Serialization.Cloning.CopyContext context) { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Copier_EventHubSequenceToken : global::Orleans.Serialization.Cloning.IDeepCopier<global::Orleans.Streaming.EventHubs.EventHubSequenceToken>, global::Orleans.Serialization.Cloning.IDeepCopier, global::Orleans.Serialization.Cloning.IBaseCopier<global::Orleans.Streaming.EventHubs.EventHubSequenceToken>, global::Orleans.Serialization.Cloning.IBaseCopier
    {
        public Copier_EventHubSequenceToken(global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public global::Orleans.Streaming.EventHubs.EventHubSequenceToken DeepCopy(global::Orleans.Streaming.EventHubs.EventHubSequenceToken original, global::Orleans.Serialization.Cloning.CopyContext context) { throw null; }

        public void DeepCopy(global::Orleans.Streaming.EventHubs.EventHubSequenceToken input, global::Orleans.Streaming.EventHubs.EventHubSequenceToken output, global::Orleans.Serialization.Cloning.CopyContext context) { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Copier_EventHubSequenceTokenV2 : global::Orleans.Serialization.Cloning.IDeepCopier<global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2>, global::Orleans.Serialization.Cloning.IDeepCopier, global::Orleans.Serialization.Cloning.IBaseCopier<global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2>, global::Orleans.Serialization.Cloning.IBaseCopier
    {
        public Copier_EventHubSequenceTokenV2(global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 DeepCopy(global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 original, global::Orleans.Serialization.Cloning.CopyContext context) { throw null; }

        public void DeepCopy(global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 input, global::Orleans.Streaming.EventHubs.EventHubSequenceTokenV2 output, global::Orleans.Serialization.Cloning.CopyContext context) { }
    }
}

namespace OrleansCodeGen.Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory
{
    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_StreamRandomPlacementArg : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg>, global::Orleans.Serialization.Codecs.IFieldCodec, global::Orleans.Serialization.Serializers.IBaseCodec<global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg>, global::Orleans.Serialization.Serializers.IBaseCodec
    {
        public Codec_StreamRandomPlacementArg(global::Orleans.Serialization.Activators.IActivator<global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg> _activator, global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public void Deserialize<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg instance) { }

        public global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void Serialize<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg instance)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Copier_StreamRandomPlacementArg : global::Orleans.Serialization.Cloning.IDeepCopier<global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg>, global::Orleans.Serialization.Cloning.IDeepCopier, global::Orleans.Serialization.Cloning.IBaseCopier<global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg>, global::Orleans.Serialization.Cloning.IBaseCopier
    {
        public Copier_StreamRandomPlacementArg(global::Orleans.Serialization.Activators.IActivator<global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg> _activator) { }

        public global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg DeepCopy(global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg original, global::Orleans.Serialization.Cloning.CopyContext context) { throw null; }

        public void DeepCopy(global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg input, global::Orleans.Streaming.EventHubs.Testing.EventDataGeneratorAdapterFactory.StreamRandomPlacementArg output, global::Orleans.Serialization.Cloning.CopyContext context) { }
    }
}