//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace Orleans.Journaling
{
    public abstract partial class DurableGrain : Grain, IGrainBase
    {
        protected IStateMachineManager StateMachineManager { get { throw null; } }

        protected TStateMachine GetOrCreateStateMachine<TStateMachine>(string name)
            where TStateMachine : class, IDurableStateMachine { throw null; }

        protected TStateMachine GetOrCreateStateMachine<TState, TStateMachine>(string name, System.Func<TState, TStateMachine> createStateMachine, TState state)
            where TStateMachine : class, IDurableStateMachine { throw null; }

        protected System.Threading.Tasks.ValueTask WriteStateAsync(System.Threading.CancellationToken cancellationToken = default) { throw null; }
    }

    [GenerateSerializer]
    [Immutable]
    public readonly partial struct DurableTaskCompletionSourceState<T>
    {
        private readonly T? _Value_k__BackingField;
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        [Id(2)]
        public System.Exception? Exception { get { throw null; } init { } }

        [Id(0)]
        public DurableTaskCompletionSourceStatus Status { get { throw null; } init { } }

        [Id(1)]
        public T? Value { get { throw null; } init { } }
    }

    [GenerateSerializer]
    public enum DurableTaskCompletionSourceStatus : byte
    {
        Pending = 0,
        Completed = 1,
        Faulted = 2,
        Canceled = 3
    }

    public static partial class HostingExtensions
    {
        public static Hosting.ISiloBuilder AddStateMachineStorage(this Hosting.ISiloBuilder builder) { throw null; }
    }

    public partial interface IDurableDictionary<K, V> : System.Collections.Generic.IDictionary<K, V>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<K, V>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K, V>>, System.Collections.IEnumerable
    {
    }

    public partial interface IDurableList<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
    {
        void AddRange(System.Collections.Generic.IEnumerable<T> collection);
        System.Collections.ObjectModel.ReadOnlyCollection<T> AsReadOnly();
    }

    public partial interface IDurableNothing
    {
    }

    public partial interface IDurableQueue<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<T>
    {
        void Clear();
        bool Contains(T item);
        void CopyTo(T[] array, int arrayIndex);
        T Dequeue();
        void Enqueue(T item);
        T Peek();
        bool TryDequeue(out T item);
        bool TryPeek(out T item);
    }

    public partial interface IDurableSet<T> : System.Collections.Generic.ISet<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IReadOnlySet<T>
    {
        int Count { get; }

        bool Add(T item);
        bool Contains(T item);
        bool IsProperSubsetOf(System.Collections.Generic.IEnumerable<T> other);
        bool IsProperSupersetOf(System.Collections.Generic.IEnumerable<T> other);
        bool IsSubsetOf(System.Collections.Generic.IEnumerable<T> other);
        bool IsSupersetOf(System.Collections.Generic.IEnumerable<T> other);
        bool Overlaps(System.Collections.Generic.IEnumerable<T> other);
        bool SetEquals(System.Collections.Generic.IEnumerable<T> other);
    }

    public partial interface IDurableStateMachine
    {
        void AppendEntries(StateMachineStorageWriter writer);
        void AppendSnapshot(StateMachineStorageWriter writer);
        void Apply(System.Buffers.ReadOnlySequence<byte> entry);
        IDurableStateMachine DeepCopy();
        void OnRecoveryCompleted();
        void OnWriteCompleted();
        void Reset(IStateMachineLogWriter storage);
    }

    public partial interface IDurableTaskCompletionSource<T>
    {
        DurableTaskCompletionSourceState<T> State { get; }

        System.Threading.Tasks.Task<T> Task { get; }

        bool TrySetCanceled();
        bool TrySetException(System.Exception exception);
        bool TrySetResult(T value);
    }

    public partial interface IDurableValue<T>
    {
        T? Value { get; set; }
    }

    public partial interface IStateMachineLogWriter
    {
        void AppendEntries<TState>(System.Action<TState, StateMachineStorageWriter> action, TState state);
        void AppendEntry<TState>(System.Action<TState, System.Buffers.IBufferWriter<byte>> action, TState state);
    }

    public partial interface IStateMachineManager
    {
        System.Threading.Tasks.ValueTask DeleteStateAsync(System.Threading.CancellationToken cancellationToken);
        System.Threading.Tasks.ValueTask InitializeAsync(System.Threading.CancellationToken cancellationToken);
        void RegisterStateMachine(string name, IDurableStateMachine stateMachine);
        bool TryGetStateMachine(string name, out IDurableStateMachine? stateMachine);
        System.Threading.Tasks.ValueTask WriteStateAsync(System.Threading.CancellationToken cancellationToken);
    }

    public partial interface IStateMachineStorage
    {
        bool IsCompactionRequested { get; }

        System.Threading.Tasks.ValueTask AppendAsync(LogExtentBuilder value, System.Threading.CancellationToken cancellationToken);
        System.Threading.Tasks.ValueTask DeleteAsync(System.Threading.CancellationToken cancellationToken);
        System.Collections.Generic.IAsyncEnumerable<LogExtent> ReadAsync(System.Threading.CancellationToken cancellationToken);
        System.Threading.Tasks.ValueTask ReplaceAsync(LogExtentBuilder value, System.Threading.CancellationToken cancellationToken);
    }

    public partial interface IStateMachineStorageProvider
    {
        IStateMachineStorage Create(Runtime.IGrainContext grainContext);
    }

    public sealed partial class LogExtent : System.IDisposable
    {
        public LogExtent() { }

        public LogExtent(Serialization.Buffers.ArcBuffer buffer) { }

        public bool IsEmpty { get { throw null; } }

        public void Dispose() { }

        public readonly partial struct Entry : System.IEquatable<Entry>
        {
            private readonly int _dummyPrimitive;
            public Entry(StateMachineId StreamId, System.Buffers.ReadOnlySequence<byte> Payload) { }

            public System.Buffers.ReadOnlySequence<byte> Payload { get { throw null; } init { } }

            public StateMachineId StreamId { get { throw null; } init { } }

            [System.Runtime.CompilerServices.CompilerGenerated]
            public readonly void Deconstruct(out StateMachineId StreamId, out System.Buffers.ReadOnlySequence<byte> Payload) { throw null; }

            [System.Runtime.CompilerServices.CompilerGenerated]
            public readonly bool Equals(Entry other) { throw null; }

            [System.Runtime.CompilerServices.CompilerGenerated]
            public override readonly bool Equals(object obj) { throw null; }

            [System.Runtime.CompilerServices.CompilerGenerated]
            public override readonly int GetHashCode() { throw null; }

            [System.Runtime.CompilerServices.CompilerGenerated]
            public static bool operator ==(Entry left, Entry right) { throw null; }

            [System.Runtime.CompilerServices.CompilerGenerated]
            public static bool operator !=(Entry left, Entry right) { throw null; }

            [System.Runtime.CompilerServices.CompilerGenerated]
            public override readonly string ToString() { throw null; }
        }
    }

    public sealed partial class LogExtentBuilder : System.IDisposable, System.Buffers.IBufferWriter<byte>
    {
        public LogExtentBuilder() { }

        public LogExtentBuilder(Serialization.Buffers.ArcBufferWriter buffer) { }

        public bool IsEmpty { get { throw null; } }

        public long Length { get { throw null; } }

        public void CopyTo(System.IO.Stream destination, int bufferSize) { }

        public System.Threading.Tasks.ValueTask CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) { throw null; }

        public StateMachineStorageWriter CreateLogWriter(StateMachineId id) { throw null; }

        public void Dispose() { }

        public void Reset() { }

        void System.Buffers.IBufferWriter<byte>.Advance(int count) { }

        System.Memory<byte> System.Buffers.IBufferWriter<byte>.GetMemory(int sizeHint) { throw null; }

        System.Span<byte> System.Buffers.IBufferWriter<byte>.GetSpan(int sizeHint) { throw null; }

        public byte[] ToArray() { throw null; }

        public sealed partial class ReadOnlyStream : System.IO.Stream
        {
            public override bool CanRead { get { throw null; } }

            public override bool CanSeek { get { throw null; } }

            public override bool CanWrite { get { throw null; } }

            public override long Length { get { throw null; } }

            public override long Position { get { throw null; } set { } }

            public override void CopyTo(System.IO.Stream destination, int bufferSize) { }

            public override System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken) { throw null; }

            public override void Flush() { }

            public override int Read(byte[] buffer, int offset, int count) { throw null; }

            public override int Read(System.Span<byte> buffer) { throw null; }

            public override System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken) { throw null; }

            public override System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken = default) { throw null; }

            public void Reset() { }

            public override long Seek(long offset, System.IO.SeekOrigin origin) { throw null; }

            public void SetBuilder(LogExtentBuilder builder) { }

            public override void SetLength(long value) { }

            public override void Write(byte[] buffer, int offset, int count) { }

            public override void Write(System.ReadOnlySpan<byte> buffer) { }

            public override System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken = default) { throw null; }

            public override void WriteByte(byte value) { }
        }
    }

    public readonly partial struct StateMachineId : System.IEquatable<StateMachineId>
    {
        private readonly int _dummyPrimitive;
        public StateMachineId(ulong Value) { }

        public ulong Value { get { throw null; } init { } }

        [System.Runtime.CompilerServices.CompilerGenerated]
        public readonly void Deconstruct(out ulong Value) { throw null; }

        [System.Runtime.CompilerServices.CompilerGenerated]
        public readonly bool Equals(StateMachineId other) { throw null; }

        [System.Runtime.CompilerServices.CompilerGenerated]
        public override readonly bool Equals(object obj) { throw null; }

        [System.Runtime.CompilerServices.CompilerGenerated]
        public override readonly int GetHashCode() { throw null; }

        [System.Runtime.CompilerServices.CompilerGenerated]
        public static bool operator ==(StateMachineId left, StateMachineId right) { throw null; }

        [System.Runtime.CompilerServices.CompilerGenerated]
        public static bool operator !=(StateMachineId left, StateMachineId right) { throw null; }

        [System.Runtime.CompilerServices.CompilerGenerated]
        public override readonly string ToString() { throw null; }
    }

    public readonly partial struct StateMachineStorageWriter
    {
        private readonly object _dummy;
        private readonly int _dummyPrimitive;
        public readonly void AppendEntry(System.ArraySegment<byte> value) { }

        public readonly void AppendEntry(System.Buffers.ReadOnlySequence<byte> value) { }

        public readonly void AppendEntry(byte[] value) { }

        public readonly void AppendEntry(System.Memory<byte> value) { }

        public readonly void AppendEntry(System.ReadOnlyMemory<byte> value) { }

        public readonly void AppendEntry(System.ReadOnlySpan<byte> value) { }

        public readonly void AppendEntry(System.Span<byte> value) { }

        public readonly void AppendEntry<T>(System.Action<T, System.Buffers.IBufferWriter<byte>> valueWriter, T value) { }
    }

    public sealed partial class VolatileStateMachineStorage : IStateMachineStorage
    {
        public bool IsCompactionRequested { get { throw null; } }

        public System.Threading.Tasks.ValueTask AppendAsync(LogExtentBuilder segment, System.Threading.CancellationToken cancellationToken) { throw null; }

        public System.Threading.Tasks.ValueTask DeleteAsync(System.Threading.CancellationToken cancellationToken) { throw null; }

        public System.Collections.Generic.IAsyncEnumerable<LogExtent> ReadAsync(System.Threading.CancellationToken cancellationToken) { throw null; }

        public System.Threading.Tasks.ValueTask ReplaceAsync(LogExtentBuilder snapshot, System.Threading.CancellationToken cancellationToken) { throw null; }
    }

    public sealed partial class VolatileStateMachineStorageProvider : IStateMachineStorageProvider
    {
        public IStateMachineStorage Create(Runtime.IGrainContext grainContext) { throw null; }
    }
}

namespace OrleansCodeGen.Orleans.Journaling
{
    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_DurableTaskCompletionSourceState<T> : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.Journaling.DurableTaskCompletionSourceState<T>>, global::Orleans.Serialization.Codecs.IFieldCodec, global::Orleans.Serialization.Serializers.IValueSerializer<global::Orleans.Journaling.DurableTaskCompletionSourceState<T>>, global::Orleans.Serialization.Serializers.IValueSerializer
    {
        public Codec_DurableTaskCompletionSourceState(global::Orleans.Serialization.Serializers.ICodecProvider codecProvider) { }

        public void Deserialize<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, scoped ref global::Orleans.Journaling.DurableTaskCompletionSourceState<T> instance) { }

        public global::Orleans.Journaling.DurableTaskCompletionSourceState<T> ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void Serialize<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, scoped ref global::Orleans.Journaling.DurableTaskCompletionSourceState<T> instance)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.Journaling.DurableTaskCompletionSourceState<T> value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Codec_DurableTaskCompletionSourceStatus : global::Orleans.Serialization.Codecs.IFieldCodec<global::Orleans.Journaling.DurableTaskCompletionSourceStatus>, global::Orleans.Serialization.Codecs.IFieldCodec
    {
        public global::Orleans.Journaling.DurableTaskCompletionSourceStatus ReadValue<TReaderInput>(ref global::Orleans.Serialization.Buffers.Reader<TReaderInput> reader, global::Orleans.Serialization.WireProtocol.Field field) { throw null; }

        public void WriteField<TBufferWriter>(ref global::Orleans.Serialization.Buffers.Writer<TBufferWriter> writer, uint fieldIdDelta, System.Type expectedType, global::Orleans.Journaling.DurableTaskCompletionSourceStatus value)
            where TBufferWriter : System.Buffers.IBufferWriter<byte> { }
    }

    [System.CodeDom.Compiler.GeneratedCode("OrleansCodeGen", "9.0.0.0")]
    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    public sealed partial class Copier_DurableTaskCompletionSourceState<T> : global::Orleans.Serialization.Cloning.ShallowCopier<global::Orleans.Journaling.DurableTaskCompletionSourceState<T>>
    {
    }
}